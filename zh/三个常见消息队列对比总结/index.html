<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>三个常见消息队列对比总结 | Xloading's Blog</title><meta name=keywords content><meta name=description content="一、总体定位与设计

  
      
          特性
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          诞生背景
          LinkedIn 为了解决日志收集、高吞吐流式处理
          AMQP 协议标准实现，追求可靠投递
          阿里为电商高并发交易场景设计
      
      
          定位
          分布式日志系统 / 流式平台
          消息代理（Broker）
          分布式消息中间件（国产 Kafka 改良版）
      
      
          核心目标
          高吞吐、可扩展、可持久化
          低延迟、可靠性、灵活路由
          高可用、顺序消息、事务消息
      
      
          使用场景
          日志采集、大数据流、实时分析
          异步任务、业务解耦、通知推送
          分布式事务、订单支付、延迟/定时消息
      
  


二、架构模型对比

  
      
          对比项
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          模型
          发布-订阅（Pub/Sub）
          生产者 → 交换机 (Exchange) → 队列 → 消费者
          主题 (Topic) + 队列 (MessageQueue)
      
      
          消息路由
          由 producer 指定 partition
          由 exchange 根据 routing key 路由
          根据 hash 或 sharding key 路由到队列
      
      
          存储
          顺序写日志（磁盘 + PageCache）
          内存优先，磁盘持久化
          文件顺序写（CommitLog + ConsumeQueue）
      
      
          通信模型
          基于 TCP，Pull 模式
          基于 AMQP，Push 模式
          Pull + 长轮询
      
      
          消息顺序
          分区内有序
          队列内有序
          队列内严格有序（支持全局有序）
      
      
          消息确认
          Offset 提交
          ACK 确认
          ACK 确认
      
      
          消息重试 / 死信
          offset 回滚
          死信队列（DLX）
          死信队列 + 重试 Topic
      
      
          消费模式
          Consumer Group
          Queue/Topic + Exchange
          Consumer Group
      
      
          扩展性
          极强（分区水平扩展）
          一般（受单机性能限制）
          良好（多队列 + Broker 集群）
      
  


三、性能与特性对比

  
      
          维度
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          吞吐量
          ⭐⭐⭐⭐（百万级/s）
          ⭐⭐（万级/s）
          ⭐⭐⭐（十万级/s）
      
      
          延迟
          低中（mss）
          极低（亚毫秒级）
          低（ms 级）
      
      
          可扩展性
          极强（分区并行）
          一般（垂直扩展为主）
          强（Broker 可水平扩展）
      
      
          持久化
          高效（顺序写）
          可选（影响性能）
          高效（多队列索引）
      
      
          消息可靠性
          高（副本 + ISR）
          高（ACK + 持久化）
          高（异步双写、主从同步）
      
      
          事务消息
          一般（0.11+ 支持）
          弱（需额外实现）
          强（原生支持事务消息）
      
      
          延迟消息
          不支持（需外部插件）
          需 TTL + DLX 实现
          原生支持定时/延迟消息
      
      
          顺序消息
          分区内有序
          队列内有序
          原生支持严格顺序消息
      
      
          消息过滤
          Consumer 端过滤
          Exchange 路由过滤
          Tag + SQL 表达式过滤
      
  


四、设计机制差异（为什么 Kafka 吞吐量最高？）

  
      
          Kafka 关键机制
          原理
      
  
  
      
          顺序写磁盘 + PageCache
          几乎等价内存写入速度
      
      
          零拷贝（Zero Copy）
          减少用户态/内核态切换
      
      
          批量发送 + 压缩
          减少网络 I/O
      
      
          分区并行读写
          天然支持水平扩展
      
      
          简化确认机制（offset）
          降低消息确认开销
      
  


五、典型应用场景推荐

  
      
          场景
          推荐消息队列
          理由
      
  
  
      
          大数据日志采集 / 实时分析
          Kafka ✅
          高吞吐、分区并行、顺序写
      
      
          订单/交易系统、支付事务
          RocketMQ ✅
          支持事务消息、延迟消息
      
      
          简单异步任务 / 通知推送
          RabbitMQ ✅
          低延迟、易用、路由灵活
      
      
          高可扩展日志系统
          Kafka
          分布式架构
      
      
          多租户 SaaS、分布式事务
          RocketMQ
          支持事务与回查机制
      
      
          IoT 实时上报、轻量级消息
          RabbitMQ
          协议成熟，延迟极低
      
  


Kafka：高吞吐、顺序写、适合日志与流式数据。
RabbitMQ：低延迟、协议丰富、适合可靠业务消息。
RocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。"><meta name=author content="axing"><link rel=canonical href=https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/><link crossorigin=anonymous href=/assets/css/stylesheet.60e9f0b6784df1409ba6f4029a0b1e6323395367cc36407f08f8538034fe128f.css integrity="sha256-YOnwtnhN8UCbpvQCmgseYyM5U2fMNkB/CPhTgDT+Eo8=" rel="preload stylesheet" as=style><link rel=icon href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=16x16 href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=32x32 href=https://Xloading-919.github.io/img/logo.jpg><link rel=apple-touch-icon href=https://Xloading-919.github.io/logo.jpg><link rel=mask-icon href=https://Xloading-919.github.io/logo.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><style>body{font-family:lxgw wenkai,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head><body></body></html><meta property="og:url" content="https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="Xloading's Blog"><meta property="og:title" content="三个常见消息队列对比总结"><meta property="og:description" content="一、总体定位与设计 特性 Kafka RabbitMQ RocketMQ 诞生背景 LinkedIn 为了解决日志收集、高吞吐流式处理 AMQP 协议标准实现，追求可靠投递 阿里为电商高并发交易场景设计 定位 分布式日志系统 / 流式平台 消息代理（Broker） 分布式消息中间件（国产 Kafka 改良版） 核心目标 高吞吐、可扩展、可持久化 低延迟、可靠性、灵活路由 高可用、顺序消息、事务消息 使用场景 日志采集、大数据流、实时分析 异步任务、业务解耦、通知推送 分布式事务、订单支付、延迟/定时消息 二、架构模型对比 对比项 Kafka RabbitMQ RocketMQ 模型 发布-订阅（Pub/Sub） 生产者 → 交换机 (Exchange) → 队列 → 消费者 主题 (Topic) + 队列 (MessageQueue) 消息路由 由 producer 指定 partition 由 exchange 根据 routing key 路由 根据 hash 或 sharding key 路由到队列 存储 顺序写日志（磁盘 + PageCache） 内存优先，磁盘持久化 文件顺序写（CommitLog + ConsumeQueue） 通信模型 基于 TCP，Pull 模式 基于 AMQP，Push 模式 Pull + 长轮询 消息顺序 分区内有序 队列内有序 队列内严格有序（支持全局有序） 消息确认 Offset 提交 ACK 确认 ACK 确认 消息重试 / 死信 offset 回滚 死信队列（DLX） 死信队列 + 重试 Topic 消费模式 Consumer Group Queue/Topic + Exchange Consumer Group 扩展性 极强（分区水平扩展） 一般（受单机性能限制） 良好（多队列 + Broker 集群） 三、性能与特性对比 维度 Kafka RabbitMQ RocketMQ 吞吐量 ⭐⭐⭐⭐（百万级/s） ⭐⭐（万级/s） ⭐⭐⭐（十万级/s） 延迟 低中（mss） 极低（亚毫秒级） 低（ms 级） 可扩展性 极强（分区并行） 一般（垂直扩展为主） 强（Broker 可水平扩展） 持久化 高效（顺序写） 可选（影响性能） 高效（多队列索引） 消息可靠性 高（副本 + ISR） 高（ACK + 持久化） 高（异步双写、主从同步） 事务消息 一般（0.11+ 支持） 弱（需额外实现） 强（原生支持事务消息） 延迟消息 不支持（需外部插件） 需 TTL + DLX 实现 原生支持定时/延迟消息 顺序消息 分区内有序 队列内有序 原生支持严格顺序消息 消息过滤 Consumer 端过滤 Exchange 路由过滤 Tag + SQL 表达式过滤 四、设计机制差异（为什么 Kafka 吞吐量最高？） Kafka 关键机制 原理 顺序写磁盘 + PageCache 几乎等价内存写入速度 零拷贝（Zero Copy） 减少用户态/内核态切换 批量发送 + 压缩 减少网络 I/O 分区并行读写 天然支持水平扩展 简化确认机制（offset） 降低消息确认开销 五、典型应用场景推荐 场景 推荐消息队列 理由 大数据日志采集 / 实时分析 Kafka ✅ 高吞吐、分区并行、顺序写 订单/交易系统、支付事务 RocketMQ ✅ 支持事务消息、延迟消息 简单异步任务 / 通知推送 RabbitMQ ✅ 低延迟、易用、路由灵活 高可扩展日志系统 Kafka 分布式架构 多租户 SaaS、分布式事务 RocketMQ 支持事务与回查机制 IoT 实时上报、轻量级消息 RabbitMQ 协议成熟，延迟极低 Kafka：高吞吐、顺序写、适合日志与流式数据。
RabbitMQ：低延迟、协议丰富、适合可靠业务消息。
RocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-29T22:54:51+08:00"><meta property="article:modified_time" content="2025-10-29T22:54:51+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="三个常见消息队列对比总结"><meta name=twitter:description content="一、总体定位与设计

  
      
          特性
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          诞生背景
          LinkedIn 为了解决日志收集、高吞吐流式处理
          AMQP 协议标准实现，追求可靠投递
          阿里为电商高并发交易场景设计
      
      
          定位
          分布式日志系统 / 流式平台
          消息代理（Broker）
          分布式消息中间件（国产 Kafka 改良版）
      
      
          核心目标
          高吞吐、可扩展、可持久化
          低延迟、可靠性、灵活路由
          高可用、顺序消息、事务消息
      
      
          使用场景
          日志采集、大数据流、实时分析
          异步任务、业务解耦、通知推送
          分布式事务、订单支付、延迟/定时消息
      
  


二、架构模型对比

  
      
          对比项
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          模型
          发布-订阅（Pub/Sub）
          生产者 → 交换机 (Exchange) → 队列 → 消费者
          主题 (Topic) + 队列 (MessageQueue)
      
      
          消息路由
          由 producer 指定 partition
          由 exchange 根据 routing key 路由
          根据 hash 或 sharding key 路由到队列
      
      
          存储
          顺序写日志（磁盘 + PageCache）
          内存优先，磁盘持久化
          文件顺序写（CommitLog + ConsumeQueue）
      
      
          通信模型
          基于 TCP，Pull 模式
          基于 AMQP，Push 模式
          Pull + 长轮询
      
      
          消息顺序
          分区内有序
          队列内有序
          队列内严格有序（支持全局有序）
      
      
          消息确认
          Offset 提交
          ACK 确认
          ACK 确认
      
      
          消息重试 / 死信
          offset 回滚
          死信队列（DLX）
          死信队列 + 重试 Topic
      
      
          消费模式
          Consumer Group
          Queue/Topic + Exchange
          Consumer Group
      
      
          扩展性
          极强（分区水平扩展）
          一般（受单机性能限制）
          良好（多队列 + Broker 集群）
      
  


三、性能与特性对比

  
      
          维度
          Kafka
          RabbitMQ
          RocketMQ
      
  
  
      
          吞吐量
          ⭐⭐⭐⭐（百万级/s）
          ⭐⭐（万级/s）
          ⭐⭐⭐（十万级/s）
      
      
          延迟
          低中（mss）
          极低（亚毫秒级）
          低（ms 级）
      
      
          可扩展性
          极强（分区并行）
          一般（垂直扩展为主）
          强（Broker 可水平扩展）
      
      
          持久化
          高效（顺序写）
          可选（影响性能）
          高效（多队列索引）
      
      
          消息可靠性
          高（副本 + ISR）
          高（ACK + 持久化）
          高（异步双写、主从同步）
      
      
          事务消息
          一般（0.11+ 支持）
          弱（需额外实现）
          强（原生支持事务消息）
      
      
          延迟消息
          不支持（需外部插件）
          需 TTL + DLX 实现
          原生支持定时/延迟消息
      
      
          顺序消息
          分区内有序
          队列内有序
          原生支持严格顺序消息
      
      
          消息过滤
          Consumer 端过滤
          Exchange 路由过滤
          Tag + SQL 表达式过滤
      
  


四、设计机制差异（为什么 Kafka 吞吐量最高？）

  
      
          Kafka 关键机制
          原理
      
  
  
      
          顺序写磁盘 + PageCache
          几乎等价内存写入速度
      
      
          零拷贝（Zero Copy）
          减少用户态/内核态切换
      
      
          批量发送 + 压缩
          减少网络 I/O
      
      
          分区并行读写
          天然支持水平扩展
      
      
          简化确认机制（offset）
          降低消息确认开销
      
  


五、典型应用场景推荐

  
      
          场景
          推荐消息队列
          理由
      
  
  
      
          大数据日志采集 / 实时分析
          Kafka ✅
          高吞吐、分区并行、顺序写
      
      
          订单/交易系统、支付事务
          RocketMQ ✅
          支持事务消息、延迟消息
      
      
          简单异步任务 / 通知推送
          RabbitMQ ✅
          低延迟、易用、路由灵活
      
      
          高可扩展日志系统
          Kafka
          分布式架构
      
      
          多租户 SaaS、分布式事务
          RocketMQ
          支持事务与回查机制
      
      
          IoT 实时上报、轻量级消息
          RabbitMQ
          协议成熟，延迟极低
      
  


Kafka：高吞吐、顺序写、适合日志与流式数据。
RabbitMQ：低延迟、协议丰富、适合可靠业务消息。
RocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://Xloading-919.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://Xloading-919.github.io/zh/posts/tech/"},{"@type":"ListItem","position":3,"name":"三个常见消息队列对比总结","item":"https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"三个常见消息队列对比总结","name":"三个常见消息队列对比总结","description":"一、总体定位与设计 特性 Kafka RabbitMQ RocketMQ 诞生背景 LinkedIn 为了解决日志收集、高吞吐流式处理 AMQP 协议标准实现，追求可靠投递 阿里为电商高并发交易场景设计 定位 分布式日志系统 / 流式平台 消息代理（Broker） 分布式消息中间件（国产 Kafka 改良版） 核心目标 高吞吐、可扩展、可持久化 低延迟、可靠性、灵活路由 高可用、顺序消息、事务消息 使用场景 日志采集、大数据流、实时分析 异步任务、业务解耦、通知推送 分布式事务、订单支付、延迟/定时消息 二、架构模型对比 对比项 Kafka RabbitMQ RocketMQ 模型 发布-订阅（Pub/Sub） 生产者 → 交换机 (Exchange) → 队列 → 消费者 主题 (Topic) + 队列 (MessageQueue) 消息路由 由 producer 指定 partition 由 exchange 根据 routing key 路由 根据 hash 或 sharding key 路由到队列 存储 顺序写日志（磁盘 + PageCache） 内存优先，磁盘持久化 文件顺序写（CommitLog + ConsumeQueue） 通信模型 基于 TCP，Pull 模式 基于 AMQP，Push 模式 Pull + 长轮询 消息顺序 分区内有序 队列内有序 队列内严格有序（支持全局有序） 消息确认 Offset 提交 ACK 确认 ACK 确认 消息重试 / 死信 offset 回滚 死信队列（DLX） 死信队列 + 重试 Topic 消费模式 Consumer Group Queue/Topic + Exchange Consumer Group 扩展性 极强（分区水平扩展） 一般（受单机性能限制） 良好（多队列 + Broker 集群） 三、性能与特性对比 维度 Kafka RabbitMQ RocketMQ 吞吐量 ⭐⭐⭐⭐（百万级/s） ⭐⭐（万级/s） ⭐⭐⭐（十万级/s） 延迟 低中（mss） 极低（亚毫秒级） 低（ms 级） 可扩展性 极强（分区并行） 一般（垂直扩展为主） 强（Broker 可水平扩展） 持久化 高效（顺序写） 可选（影响性能） 高效（多队列索引） 消息可靠性 高（副本 + ISR） 高（ACK + 持久化） 高（异步双写、主从同步） 事务消息 一般（0.11+ 支持） 弱（需额外实现） 强（原生支持事务消息） 延迟消息 不支持（需外部插件） 需 TTL + DLX 实现 原生支持定时/延迟消息 顺序消息 分区内有序 队列内有序 原生支持严格顺序消息 消息过滤 Consumer 端过滤 Exchange 路由过滤 Tag + SQL 表达式过滤 四、设计机制差异（为什么 Kafka 吞吐量最高？） Kafka 关键机制 原理 顺序写磁盘 + PageCache 几乎等价内存写入速度 零拷贝（Zero Copy） 减少用户态/内核态切换 批量发送 + 压缩 减少网络 I/O 分区并行读写 天然支持水平扩展 简化确认机制（offset） 降低消息确认开销 五、典型应用场景推荐 场景 推荐消息队列 理由 大数据日志采集 / 实时分析 Kafka ✅ 高吞吐、分区并行、顺序写 订单/交易系统、支付事务 RocketMQ ✅ 支持事务消息、延迟消息 简单异步任务 / 通知推送 RabbitMQ ✅ 低延迟、易用、路由灵活 高可扩展日志系统 Kafka 分布式架构 多租户 SaaS、分布式事务 RocketMQ 支持事务与回查机制 IoT 实时上报、轻量级消息 RabbitMQ 协议成熟，延迟极低 Kafka：高吞吐、顺序写、适合日志与流式数据。\nRabbitMQ：低延迟、协议丰富、适合可靠业务消息。\nRocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。\n","keywords":[],"articleBody":"一、总体定位与设计 特性 Kafka RabbitMQ RocketMQ 诞生背景 LinkedIn 为了解决日志收集、高吞吐流式处理 AMQP 协议标准实现，追求可靠投递 阿里为电商高并发交易场景设计 定位 分布式日志系统 / 流式平台 消息代理（Broker） 分布式消息中间件（国产 Kafka 改良版） 核心目标 高吞吐、可扩展、可持久化 低延迟、可靠性、灵活路由 高可用、顺序消息、事务消息 使用场景 日志采集、大数据流、实时分析 异步任务、业务解耦、通知推送 分布式事务、订单支付、延迟/定时消息 二、架构模型对比 对比项 Kafka RabbitMQ RocketMQ 模型 发布-订阅（Pub/Sub） 生产者 → 交换机 (Exchange) → 队列 → 消费者 主题 (Topic) + 队列 (MessageQueue) 消息路由 由 producer 指定 partition 由 exchange 根据 routing key 路由 根据 hash 或 sharding key 路由到队列 存储 顺序写日志（磁盘 + PageCache） 内存优先，磁盘持久化 文件顺序写（CommitLog + ConsumeQueue） 通信模型 基于 TCP，Pull 模式 基于 AMQP，Push 模式 Pull + 长轮询 消息顺序 分区内有序 队列内有序 队列内严格有序（支持全局有序） 消息确认 Offset 提交 ACK 确认 ACK 确认 消息重试 / 死信 offset 回滚 死信队列（DLX） 死信队列 + 重试 Topic 消费模式 Consumer Group Queue/Topic + Exchange Consumer Group 扩展性 极强（分区水平扩展） 一般（受单机性能限制） 良好（多队列 + Broker 集群） 三、性能与特性对比 维度 Kafka RabbitMQ RocketMQ 吞吐量 ⭐⭐⭐⭐（百万级/s） ⭐⭐（万级/s） ⭐⭐⭐（十万级/s） 延迟 低中（mss） 极低（亚毫秒级） 低（ms 级） 可扩展性 极强（分区并行） 一般（垂直扩展为主） 强（Broker 可水平扩展） 持久化 高效（顺序写） 可选（影响性能） 高效（多队列索引） 消息可靠性 高（副本 + ISR） 高（ACK + 持久化） 高（异步双写、主从同步） 事务消息 一般（0.11+ 支持） 弱（需额外实现） 强（原生支持事务消息） 延迟消息 不支持（需外部插件） 需 TTL + DLX 实现 原生支持定时/延迟消息 顺序消息 分区内有序 队列内有序 原生支持严格顺序消息 消息过滤 Consumer 端过滤 Exchange 路由过滤 Tag + SQL 表达式过滤 四、设计机制差异（为什么 Kafka 吞吐量最高？） Kafka 关键机制 原理 顺序写磁盘 + PageCache 几乎等价内存写入速度 零拷贝（Zero Copy） 减少用户态/内核态切换 批量发送 + 压缩 减少网络 I/O 分区并行读写 天然支持水平扩展 简化确认机制（offset） 降低消息确认开销 五、典型应用场景推荐 场景 推荐消息队列 理由 大数据日志采集 / 实时分析 Kafka ✅ 高吞吐、分区并行、顺序写 订单/交易系统、支付事务 RocketMQ ✅ 支持事务消息、延迟消息 简单异步任务 / 通知推送 RabbitMQ ✅ 低延迟、易用、路由灵活 高可扩展日志系统 Kafka 分布式架构 多租户 SaaS、分布式事务 RocketMQ 支持事务与回查机制 IoT 实时上报、轻量级消息 RabbitMQ 协议成熟，延迟极低 Kafka：高吞吐、顺序写、适合日志与流式数据。\nRabbitMQ：低延迟、协议丰富、适合可靠业务消息。\nRocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。\n","wordCount":"1117","inLanguage":"zh","datePublished":"2025-10-29T22:54:51+08:00","dateModified":"2025-10-29T22:54:51+08:00","author":[{"@type":"Person","name":"axing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"Xloading's Blog","logo":{"@type":"ImageObject","url":"https://Xloading-919.github.io/img/logo.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Xloading-919.github.io/zh/ accesskey=h title="Xloading's Blog (Alt + H)">Xloading's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Xloading-919.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://Xloading-919.github.io/zh/posts title=文章><span>文章</span></a></li><li><a href=https://Xloading-919.github.io/zh/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://Xloading-919.github.io/zh/tags title=标签><span>标签</span></a></li><li><a href=https://Xloading-919.github.io/zh/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://Xloading-919.github.io/zh/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Xloading-919.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://Xloading-919.github.io/zh/posts/>所有文章</a>&nbsp;»&nbsp;<a href=https://Xloading-919.github.io/zh/posts/tech/>技术</a></div><h1 class="post-title entry-hint-parent">三个常见消息队列对比总结</h1><div class=post-meta><span title='2025-10-29 22:54:51 +0800 +0800'>2025-10-29</span>&nbsp;·&nbsp;<span>3 分钟</span>&nbsp;·&nbsp;<span>axing</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e6%80%bb%e4%bd%93%e5%ae%9a%e4%bd%8d%e4%b8%8e%e8%ae%be%e8%ae%a1 aria-label=一、总体定位与设计>一、总体定位与设计</a></li><li><a href=#%e4%ba%8c%e6%9e%b6%e6%9e%84%e6%a8%a1%e5%9e%8b%e5%af%b9%e6%af%94 aria-label=二、架构模型对比>二、架构模型对比</a></li><li><a href=#%e4%b8%89%e6%80%a7%e8%83%bd%e4%b8%8e%e7%89%b9%e6%80%a7%e5%af%b9%e6%af%94 aria-label=三、性能与特性对比>三、性能与特性对比</a></li><li><a href=#%e5%9b%9b%e8%ae%be%e8%ae%a1%e6%9c%ba%e5%88%b6%e5%b7%ae%e5%bc%82%e4%b8%ba%e4%bb%80%e4%b9%88-kafka-%e5%90%9e%e5%90%90%e9%87%8f%e6%9c%80%e9%ab%98 aria-label="四、设计机制差异（为什么 Kafka 吞吐量最高？）">四、设计机制差异（为什么 Kafka 吞吐量最高？）</a></li><li><a href=#%e4%ba%94%e5%85%b8%e5%9e%8b%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%8e%a8%e8%8d%90 aria-label=五、典型应用场景推荐>五、典型应用场景推荐</a></li></ul></div></details></div><div class=post-content><h2 id=一总体定位与设计>一、总体定位与设计<a hidden class=anchor aria-hidden=true href=#一总体定位与设计>#</a></h2><table><thead><tr><th style=text-align:left>特性</th><th style=text-align:left><strong>Kafka</strong></th><th style=text-align:left><strong>RabbitMQ</strong></th><th style=text-align:left><strong>RocketMQ</strong></th></tr></thead><tbody><tr><td style=text-align:left>诞生背景</td><td style=text-align:left>LinkedIn 为了解决日志收集、高吞吐流式处理</td><td style=text-align:left>AMQP 协议标准实现，追求可靠投递</td><td style=text-align:left>阿里为电商高并发交易场景设计</td></tr><tr><td style=text-align:left>定位</td><td style=text-align:left>分布式日志系统 / 流式平台</td><td style=text-align:left>消息代理（Broker）</td><td style=text-align:left>分布式消息中间件（国产 Kafka 改良版）</td></tr><tr><td style=text-align:left>核心目标</td><td style=text-align:left><strong>高吞吐、可扩展、可持久化</strong></td><td style=text-align:left><strong>低延迟、可靠性、灵活路由</strong></td><td style=text-align:left><strong>高可用、顺序消息、事务消息</strong></td></tr><tr><td style=text-align:left>使用场景</td><td style=text-align:left>日志采集、大数据流、实时分析</td><td style=text-align:left>异步任务、业务解耦、通知推送</td><td style=text-align:left>分布式事务、订单支付、延迟/定时消息</td></tr></tbody></table><hr><h2 id=二架构模型对比>二、架构模型对比<a hidden class=anchor aria-hidden=true href=#二架构模型对比>#</a></h2><table><thead><tr><th style=text-align:left>对比项</th><th style=text-align:left><strong>Kafka</strong></th><th style=text-align:left><strong>RabbitMQ</strong></th><th style=text-align:left><strong>RocketMQ</strong></th></tr></thead><tbody><tr><td style=text-align:left>模型</td><td style=text-align:left>发布-订阅（Pub/Sub）</td><td style=text-align:left>生产者 → 交换机 (Exchange) → 队列 → 消费者</td><td style=text-align:left>主题 (Topic) + 队列 (MessageQueue)</td></tr><tr><td style=text-align:left>消息路由</td><td style=text-align:left>由 producer 指定 partition</td><td style=text-align:left>由 exchange 根据 routing key 路由</td><td style=text-align:left>根据 hash 或 sharding key 路由到队列</td></tr><tr><td style=text-align:left>存储</td><td style=text-align:left>顺序写日志（磁盘 + PageCache）</td><td style=text-align:left>内存优先，磁盘持久化</td><td style=text-align:left>文件顺序写（CommitLog + ConsumeQueue）</td></tr><tr><td style=text-align:left>通信模型</td><td style=text-align:left>基于 TCP，Pull 模式</td><td style=text-align:left>基于 AMQP，Push 模式</td><td style=text-align:left>Pull + 长轮询</td></tr><tr><td style=text-align:left>消息顺序</td><td style=text-align:left><strong>分区内有序</strong></td><td style=text-align:left>队列内有序</td><td style=text-align:left>队列内严格有序（支持全局有序）</td></tr><tr><td style=text-align:left>消息确认</td><td style=text-align:left>Offset 提交</td><td style=text-align:left>ACK 确认</td><td style=text-align:left>ACK 确认</td></tr><tr><td style=text-align:left>消息重试 / 死信</td><td style=text-align:left>offset 回滚</td><td style=text-align:left>死信队列（DLX）</td><td style=text-align:left>死信队列 + 重试 Topic</td></tr><tr><td style=text-align:left>消费模式</td><td style=text-align:left>Consumer Group</td><td style=text-align:left>Queue/Topic + Exchange</td><td style=text-align:left>Consumer Group</td></tr><tr><td style=text-align:left>扩展性</td><td style=text-align:left><strong>极强（分区水平扩展）</strong></td><td style=text-align:left>一般（受单机性能限制）</td><td style=text-align:left><strong>良好（多队列 + Broker 集群）</strong></td></tr></tbody></table><hr><h2 id=三性能与特性对比>三、性能与特性对比<a hidden class=anchor aria-hidden=true href=#三性能与特性对比>#</a></h2><table><thead><tr><th style=text-align:left>维度</th><th style=text-align:left><strong>Kafka</strong></th><th style=text-align:left><strong>RabbitMQ</strong></th><th style=text-align:left><strong>RocketMQ</strong></th></tr></thead><tbody><tr><td style=text-align:left>吞吐量</td><td style=text-align:left>⭐⭐⭐⭐（百万级/s）</td><td style=text-align:left>⭐⭐（万级/s）</td><td style=text-align:left>⭐⭐⭐（十万级/s）</td></tr><tr><td style=text-align:left>延迟</td><td style=text-align:left>低<del>中（ms</del>s）</td><td style=text-align:left>极低（亚毫秒级）</td><td style=text-align:left>低（ms 级）</td></tr><tr><td style=text-align:left>可扩展性</td><td style=text-align:left>极强（分区并行）</td><td style=text-align:left>一般（垂直扩展为主）</td><td style=text-align:left>强（Broker 可水平扩展）</td></tr><tr><td style=text-align:left>持久化</td><td style=text-align:left>高效（顺序写）</td><td style=text-align:left>可选（影响性能）</td><td style=text-align:left>高效（多队列索引）</td></tr><tr><td style=text-align:left>消息可靠性</td><td style=text-align:left>高（副本 + ISR）</td><td style=text-align:left>高（ACK + 持久化）</td><td style=text-align:left>高（异步双写、主从同步）</td></tr><tr><td style=text-align:left>事务消息</td><td style=text-align:left>一般（0.11+ 支持）</td><td style=text-align:left>弱（需额外实现）</td><td style=text-align:left><strong>强（原生支持事务消息）</strong></td></tr><tr><td style=text-align:left>延迟消息</td><td style=text-align:left>不支持（需外部插件）</td><td style=text-align:left>需 TTL + DLX 实现</td><td style=text-align:left><strong>原生支持定时/延迟消息</strong></td></tr><tr><td style=text-align:left>顺序消息</td><td style=text-align:left>分区内有序</td><td style=text-align:left>队列内有序</td><td style=text-align:left><strong>原生支持严格顺序消息</strong></td></tr><tr><td style=text-align:left>消息过滤</td><td style=text-align:left>Consumer 端过滤</td><td style=text-align:left>Exchange 路由过滤</td><td style=text-align:left><strong>Tag + SQL 表达式过滤</strong></td></tr></tbody></table><hr><h2 id=四设计机制差异为什么-kafka-吞吐量最高>四、设计机制差异（为什么 Kafka 吞吐量最高？）<a hidden class=anchor aria-hidden=true href=#四设计机制差异为什么-kafka-吞吐量最高>#</a></h2><table><thead><tr><th style=text-align:left>Kafka 关键机制</th><th style=text-align:left>原理</th></tr></thead><tbody><tr><td style=text-align:left><strong>顺序写磁盘 + PageCache</strong></td><td style=text-align:left>几乎等价内存写入速度</td></tr><tr><td style=text-align:left><strong>零拷贝（Zero Copy）</strong></td><td style=text-align:left>减少用户态/内核态切换</td></tr><tr><td style=text-align:left><strong>批量发送 + 压缩</strong></td><td style=text-align:left>减少网络 I/O</td></tr><tr><td style=text-align:left><strong>分区并行读写</strong></td><td style=text-align:left>天然支持水平扩展</td></tr><tr><td style=text-align:left><strong>简化确认机制（offset）</strong></td><td style=text-align:left>降低消息确认开销</td></tr></tbody></table><hr><h2 id=五典型应用场景推荐>五、典型应用场景推荐<a hidden class=anchor aria-hidden=true href=#五典型应用场景推荐>#</a></h2><table><thead><tr><th style=text-align:left>场景</th><th style=text-align:left>推荐消息队列</th><th style=text-align:left>理由</th></tr></thead><tbody><tr><td style=text-align:left>大数据日志采集 / 实时分析</td><td style=text-align:left><strong>Kafka ✅</strong></td><td style=text-align:left>高吞吐、分区并行、顺序写</td></tr><tr><td style=text-align:left>订单/交易系统、支付事务</td><td style=text-align:left><strong>RocketMQ ✅</strong></td><td style=text-align:left>支持事务消息、延迟消息</td></tr><tr><td style=text-align:left>简单异步任务 / 通知推送</td><td style=text-align:left><strong>RabbitMQ ✅</strong></td><td style=text-align:left>低延迟、易用、路由灵活</td></tr><tr><td style=text-align:left>高可扩展日志系统</td><td style=text-align:left>Kafka</td><td style=text-align:left>分布式架构</td></tr><tr><td style=text-align:left>多租户 SaaS、分布式事务</td><td style=text-align:left>RocketMQ</td><td style=text-align:left>支持事务与回查机制</td></tr><tr><td style=text-align:left>IoT 实时上报、轻量级消息</td><td style=text-align:left>RabbitMQ</td><td style=text-align:left>协议成熟，延迟极低</td></tr></tbody></table><blockquote><p><strong>Kafka</strong>：高吞吐、顺序写、适合日志与流式数据。<br><strong>RabbitMQ</strong>：低延迟、协议丰富、适合可靠业务消息。<br><strong>RocketMQ</strong>：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://Xloading-919.github.io/zh/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/><span class=title>下一页 »</span><br><span>单例模式几种实现方式</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://Xloading-919.github.io/zh/>Xloading's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>