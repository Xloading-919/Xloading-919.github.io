[{"content":"单例模式是什么 单例模式是创建型设计模式的一种，保证一个类只有一个实例，并提供一个全局访问点。 常用于全局共享资源，比如配置管理、连接池、日志对象。 作用 可以节省资源，避免频繁创建销毁对象，占用内存或系统资源 提供统一的访问入口，方便管理 保证全局只有一个对象，避免状态不一致 实现方式 饿汉式（类加载时就创建） 1 2 3 4 5 6 7 8 9 public class Singleton { // 这里要用final，初始化后不再修改 private static final Singleton instance = new Singleton(); private Singleton () {} // 设置私有访问权限的构造方法，防止外部调用 // 设置静态方法，提供全局类名访问方式 public static Singleton getInstance() { return instance; } } 优点：线程安全（JVM保证类加载时只执行一次） 缺点：类加载就创建，可能浪费资源 懒汉式（第一次用再加载） 1 2 3 4 5 6 7 8 9 10 11 public class Singleton { private static Singleton instance; private Singleton () {} // 这里需要加锁，每次只允许第一个创建或者获取 public static synchronized Singleton getInstace () { if (intstance == null) { // 判断是否已经存在了 instance = new Singleton(); } return instance; } } 优点：延迟加载 缺点：每次加锁，性能差 双重检查锁（DCL）懒汉式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Singleton { // volatile 防止指令重排，保证对象初始化完整可见 // 比如，A已经进入调用了构造函数，但是还没初始化完成 // B这时候去判断instance不为空，但是返回得到的是一个半初始化对象 private static volatile Singleton instance; private Singleton () {} public static getInstance() { if (instance == null) { // 第一次检查（避免不必要的同步） synchronized (Singleton.class) { // 锁确保只有一个线程进入初始化段 if (instance == null) { // 第二次检查（防止重复创建） instance = new Singleton();// 创建并赋值 } } } return instance; // 返回单例引用 } } 优点：兼顾 性能（避免每次都加锁） 与 线程安全（只创建一次） 缺点：代码略显复杂。 volatile的两个作用 可见性：一个线程对 instance 的写（赋值）会被其他线程立即看到；没有 volatile，一个线程修改可能对其他线程不可见（在 CPU 缓存中滞留）。 禁止指令重排（防止“半初始化对象”）：new Singleton() 在字节码/机器指令层面可能被重排序成（分配内存 → 赋值引用 → 调用构造器），若发生这种重排，另一个线程可能在构造器还没执行完时看到 instance != null 并使用一个“尚未完整初始化”的对象。volatile 引入内存栅栏，使得写 instance 不会在对象构造完成之前被发布，从而避免这个问题。 静态内部类 1 2 3 4 5 6 7 8 9 10 public class Singleton { private Singleton() {} private static class Holder { // 通过静态内部类中的静态变量初始化实例 private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return Holder.instance; // 通过内部类获取 } } 第一次调用 getInstance() 方法时，需要使用到Holder.instance，于是JVM 会加载 Holder 类，加载Holder 类时，初始化静态变量，执行new Singleton()，成功创建。 后续调用getInstance() 时，Holder 已经加载过了，INSTANCE 已存在，直接返回即可。 为什么可用：类的初始化阶段（\u0026lt;clinit\u0026gt;）是线程安全的，同一个类只会被加载和初始化一次。 枚举实现（最安全） 1 2 3 4 5 6 7 public enum Singleton { INSTANCE; // 这个方法就是在业务代码中，调用Singleton.INSTANCE获取单例对象后，调用的方法逻辑 // 调用时，都是用同一个实例调用的 public void doSomething() {} } 破坏单例 序列化 序列化会破坏非枚举单例模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Singleton s1 = Singleton.getInstance(); // 序列化到文件 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;a.obj)); oos.writeObject(s1); oos.close(); // 从文件反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;a.obj\u0026#34;)); Singleton s2 = (Singleton) ois.readObject(); ois.close(); System.out.println(s1 == s2); // false 输出false，即反序列化得到的对象时一个新的实例，破坏了单例。因为Java反序列化机制通过反射创建一个新对象，不会调用构造方法， 也不会执行getInstance()。所以每次readObject()都会产生一个新的对象副本。\n解决方案 通过实现readResolve()可以解决，在类中添加这个方法：\n1 2 3 private Object readResolve() throws ObjectStreamException { return instance; } 当 JVM 反序列化时，会优先调用 readResolve()， 把返回的对象当作反序列化结果返回，从而保证返回的仍然是原有的单例实例。\n反射调用私有构造方法 正常情况下，因为单例类中设置了构造方法的访问修饰符是private，不能再外部直接访问。但是反射可以绕过权限检查：\n1 2 3 4 5 6 7 8 Constructor\u0026lt;Singleton\u0026gt; c = Singleton.class.getDeclaredConstructor(); c.setAccessible(true); // 重要：设置可访问，关闭访问检查 Singleton s1 = Singleton.getInstance(); Singleton s2 = c.newInstance(); // 调用无参构造器创建此 Class 对象所表示的类的一个新实例。 System.out.println(s1 == s2); // false 输出是false，说明反射调用私有构造器创建了新对象实例，破坏单例唯一性。\n使用枚举类解决 使用枚举类实现单例模式，可以防止两种破坏。\n枚举反序列化时不会new新对象，而是直接用类加载时创建的那个枚举实例。 枚举的构造器是由JVM特殊处理的，在类加载时自动调用，反射不能通过构造器类（Constructor.newInstance()）调用枚举的构造器，也就是不能通过反射创建枚举实例。 ","permalink":"https://Xloading-919.github.io/zh/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","summary":"\u003ch2 id=\"单例模式是什么\"\u003e单例模式是什么\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e单例模式是创建型设计模式的一种，保证\u003cstrong\u003e一个类只有一个实例\u003c/strong\u003e，并提供一个\u003cstrong\u003e全局访问点\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e常用于全局共享资源，比如配置管理、连接池、日志对象。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"作用\"\u003e作用\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e可以节省资源，避免频繁创建销毁对象，占用内存或系统资源\u003c/li\u003e\n\u003cli\u003e提供统一的访问入口，方便管理\u003c/li\u003e\n\u003cli\u003e保证全局只有一个对象，避免状态不一致\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"实现方式\"\u003e实现方式\u003c/h2\u003e\n\u003ch3 id=\"饿汉式类加载时就创建\"\u003e饿汉式（类加载时就创建）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"c1\"\u003e// 这里要用final，初始化后不再修改\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003efinal\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 设置私有访问权限的构造方法，防止外部调用\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"c1\"\u003e// 设置静态方法，提供全局类名访问方式\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetInstance\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e优点：线程安全（JVM保证类加载时只执行一次）\u003c/li\u003e\n\u003cli\u003e缺点：类加载就创建，可能浪费资源\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"懒汉式第一次用再加载\"\u003e懒汉式（第一次用再加载）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 这里需要加锁，每次只允许第一个创建或者获取\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003esynchronized\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetInstace\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eintstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 判断是否已经存在了\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e优点：延迟加载\u003c/li\u003e\n\u003cli\u003e缺点：每次加锁，性能差\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"双重检查锁dcl懒汉式\"\u003e双重检查锁（DCL）懒汉式\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// volatile 防止指令重排，保证对象初始化完整可见\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 比如，A已经进入调用了构造函数，但是还没初始化完成\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// B这时候去判断instance不为空，但是返回得到的是一个半初始化对象\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003evolatile\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetInstance\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 第一次检查（避免不必要的同步）\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"kd\"\u003esynchronized\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eclass\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 锁确保只有一个线程进入初始化段\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 第二次检查（防止重复创建）\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                    \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"c1\"\u003e// 创建并赋值\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 返回单例引用\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e优点：兼顾 \u003cstrong\u003e性能（避免每次都加锁）\u003c/strong\u003e 与 \u003cstrong\u003e线程安全（只创建一次）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e缺点：代码略显复杂。\u003c/li\u003e\n\u003cli\u003evolatile的两个作用\n\u003col\u003e\n\u003cli\u003e可见性：一个线程对 \u003ccode\u003einstance\u003c/code\u003e 的写（赋值）会被其他线程立即看到；没有 \u003ccode\u003evolatile\u003c/code\u003e，一个线程修改可能对其他线程不可见（在 CPU 缓存中滞留）。\u003c/li\u003e\n\u003cli\u003e禁止指令重排（防止“半初始化对象”）：\u003ccode\u003enew Singleton()\u003c/code\u003e 在字节码/机器指令层面可能被重排序成（分配内存 → 赋值引用 → 调用构造器），若发生这种重排，另一个线程可能在构造器还没执行完时看到 \u003ccode\u003einstance != null\u003c/code\u003e 并使用一个“尚未完整初始化”的对象。\u003ccode\u003evolatile\u003c/code\u003e 引入内存栅栏，使得写 \u003ccode\u003einstance\u003c/code\u003e 不会在对象构造完成之前被发布，从而避免这个问题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"静态内部类\"\u003e静态内部类\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eHolder\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 通过静态内部类中的静态变量初始化实例\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003efinal\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003estatic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetInstance\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eHolder\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 通过内部类获取\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e第一次调用 \u003ccode\u003egetInstance()\u003c/code\u003e 方法时，需要使用到\u003ccode\u003eHolder.instance\u003c/code\u003e，于是JVM 会加载 \u003ccode\u003eHolder\u003c/code\u003e 类，加载\u003ccode\u003eHolder\u003c/code\u003e 类时，初始化静态变量，执行\u003ccode\u003enew Singleton()\u003c/code\u003e，成功创建。\u003c/li\u003e\n\u003cli\u003e后续调用\u003ccode\u003egetInstance()\u003c/code\u003e 时，\u003ccode\u003eHolder\u003c/code\u003e 已经加载过了，\u003ccode\u003eINSTANCE\u003c/code\u003e 已存在，直接返回即可。\u003c/li\u003e\n\u003cli\u003e为什么可用：\u003cstrong\u003e类的初始化阶段（\u0026lt;clinit\u0026gt;）是线程安全的\u003c/strong\u003e，同一个类只会被加载和初始化一次。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"枚举实现最安全\"\u003e枚举实现（最安全）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eenum\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSingleton\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"n\"\u003eINSTANCE\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 这个方法就是在业务代码中，调用Singleton.INSTANCE获取单例对象后，调用的方法逻辑\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 调用时，都是用同一个实例调用的\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"破坏单例\"\u003e破坏单例\u003c/h2\u003e\n\u003ch3 id=\"序列化\"\u003e序列化\u003c/h3\u003e\n\u003cp\u003e序列化会破坏非枚举单例模式：\u003c/p\u003e","title":"单例模式几种实现方式"},{"content":"15. 三数之和 要求：找到和为0的三个数的组合，三个数不能重复。\n思路：排序双指针求和 这里因为不要求下标，只需要记录数值，所以可以排序打乱，先排序 三个数，可以先固定一个数在最左边，另外两个数在后面的部分使用双指针求得 遍历每个位置作为最左边得数，得到所有答案 最优就是$O(n^2)$复杂度了 要求不能重复， 外层遍历最左边的数时，跳过和前一次遍历相同的数 内层遍历时，在和为0时，两个指针指向的数收缩时也要跳过相同的数值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i \u0026lt; n - 2; i++) { int x = nums[i]; // 这里跳过重复的i，从第二个开始判断 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i - 1] == x) continue; // 额外的两个优化： //如果最小的x和相邻两个最小的值的和已经超出0，则直接结束返回空 if(x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; //如果最小的x和最后两个最大的值的和还不够0，则跳过这个x，检查下一个 if(x + nums[n - 1] + nums[n - 2] \u0026lt; 0) continue; int j = i + 1; int k = n - 1; while (j \u0026lt; k) { int y = nums[j]; int z = nums[k]; int s = x + y + z; if (s \u0026gt; 0) { k--; } else if (s \u0026lt; 0) { j++; } else { // 注意这里怎么构建元组的 ans.add(List.of(x, y, z)); while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] == y) j++; while (j \u0026lt; k \u0026amp;\u0026amp; nums[k] == z) k--; } } } return ans; } } 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 88. 合并两个有序数组 要求：两个非递减数组合并，从最后开始合并。\n思路 合并的结果放到数组1中，需要有三个指针分别指向操作数组的最后的位置 要注意循环条件，下面使用两个分开的循环更清晰点 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { // 记录最后一个位置 int p1 = m - 1; int p2 = n - 1; int p = m + n - 1; // while (p2 \u0026gt;= 0) { // 移动p2，如果p2都移动完了，剩余nums1中的数都不用移动了 // if (p1 \u0026gt;= 0 \u0026amp;\u0026amp; nums1[p1] \u0026gt; nums2[p2]) { // nums1[p--] = nums1[p1--]; // } else { // nums1[p--] = nums2[p2--]; // } // } while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { if (nums1[p1] \u0026gt; nums2[p2]) { nums1[p--] = nums1[p1--]; } else { // 相同时移动nums2，nums1不动 nums1[p--] = nums2[p2--]; } } while (p2 \u0026gt;= 0) { // 如果nums2还有剩余的就移动，如果没有，nums1中的已经时排好的 nums1[p--] = nums2[p2--]; } } } 时间复杂度：$O(m + n)$ 空间复杂度：$O(1)$ 42. 接雨水 要求：看图求能存多少水\n思路 相向双指针：通过遍历找柱子左右最低的桶壁，其决定了这里能装多少水 注意，是记录前面最大的地方和后面最大的地方 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int trap(int[] height) { int i = 0; int j = height.length - 1; int maxL = 0; int maxR = 0; int ans = 0; while (i \u0026lt; j) { maxL = Math.max(maxL, height[i]); maxR = Math.max(maxR, height[j]); // 计算一个地方的左边最大值和右边最大值 // 小的那一个最大值可以用来计算这个地方的接水的容量 // 即：那个小的最大值 和 当前位置的高度 的差值 // 因为这个一个柱子能接多少水是由最小的桶壁和这里桶底的高度决定的 if (maxL \u0026lt; maxR) { ans += maxL - height[i++]; // 这个位置算了之后，移动指针 } else { ans += maxR - height[j--]; } } return ans; } } 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 209. 长度最小的子数组 要求：求总和大于等于target的最短子数组的长度\n思路：滑动窗口 同向双指针，右指针扩大并计算和 满足条件时，左指针收缩，并更新最小长度 注意，求最小值，ans要设定为一个不可能到达的最大值，便于更新 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int minSubArrayLen(int target, int[] nums) { int n = nums.length; int ans = n + 1; // 最多n + 1长 int left = 0; int right = 0; int sum = 0; while (right \u0026lt; n) { sum += nums[right]; while (sum \u0026gt;= target) { ans = Math.min(ans, right - left + 1); sum -= nums[left++]; } right++; } return ans == n + 1 ? 0 : ans; } } 时间复杂度：$O(n)$，其中 n 为 nums 的长度。虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 n 次，所以总的时间复杂度为 $O(n)$。 每个元素被 left 和 right 各“经过”一次。总共操作次数 \u0026lt;= 2n 空间复杂度：$O(1)$ 283. 移动零 要求：把数组中的0都移动到末尾，保持非零元素的相对顺序\n思路 同向双指针，右指针遇到非零值时和左指针交换 左指针再交换后再右移 这样，左指针每个走过的位置都变为非零值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = 0; int n = nums.length; while (j \u0026lt; n) { if (nums[j] != 0) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; i++; } j++; } } } 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 11. 盛最多水的容器 要求：看图求两个高度组成最大面积\n思路 确定两个柱子后，底边相同，面积是由更矮的那个边决定的 如果要找到更大的面积，就应该考虑把更矮的边增高，于是，把矮边想内移动，直到找到更高的边，这样才可能由更大的面积（因为底边短了，只有高度增加才可能变大） 在每次找到两个柱子时更新ans 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int maxArea(int[] height) { int ans = 0; int l = 0; int n = height.length; int r = n - 1; while (l \u0026lt; r) { int area = (r - l) * Math.min(height[l], height[r]); ans = Math.max(ans, area); if (height[l] \u0026lt; height[r]) { // 提前跳过高度更低或者相等的 int tmp = height[l]; while (l \u0026lt; r \u0026amp;\u0026amp; height[l] \u0026lt;= tmp) { l++; } } else { int tmp = height[r]; while (l \u0026lt; r \u0026amp;\u0026amp; height[r] \u0026lt;= tmp) { r--; } } } return ans; } } 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 75. 颜色分类 要求：把三种颜色分区排列。\n思路 三个指针划分处三个区域。low左侧和high右侧的位置表示已经处理结束了。mid处是正在判断处理的 移动mid指针： 为0，则和low交换 low处已经为0，则加1 mid处加1 为1，则跳过 不处理 mid加1 为2，则和high交换 high处变为2，则减1 mid处需要判断换回来的值是哪个，这次不移动 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public void sortColors(int[] nums) { int n = nums.length; int low = 0; int mid = 0; int high = n - 1; while (mid \u0026lt;= high) { // 需要等号，high--之后可能和mid相同，需要继续判断 int x = nums[mid]; if (x == 0) { swap(nums, mid, low); low++; mid++; } else if (x == 1) { mid++; } else { swap(nums, mid, high); high--; } } } public void swap(int[] nums, int i, int j) { int tmp = nums[j]; nums[j] = nums[i]; nums[i] = tmp; } } 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 287. 寻找重复数 要求：n+1大小的数组中存了，在[1, n]范围内的数字，存在一个重复的数字，求重复的那个数字。只能用常数空间，不修改数组。\n思路 类似环形链表中的快慢指针法 把数组的值和数组的下标看作链表的结构，数组的值就是节点 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findDuplicate(int[] nums) { int head = 0; int slow = 0; int fast = 0; while (true) { // nums[x]相当于x指向的下一个节点 fast = nums[nums[fast]]; slow = nums[slow]; if (slow == fast) { // 有环存在 while (slow != head) { head = nums[head]; slow = nums[slow]; } return slow; } } } } 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 763. 划分字母区间 要求：把字符串中的字母划分区间，每个区间内的字母不能出现在其他区间内。\n思路 本质类似：56. 合并区间 不是通过双指针遍历，单元素i遍历，使用两个边界指针控制i更新和记录答案 算是滑动窗口，通过记录每个字母在字符串中最后出现的位置，再扩张窗口的时候，根据右指针遍历到的字符在字符串中最后出现的位置，来更新右边界。 记录答案的条件是，当目前遍历到的位置和这个位置字母的最后出现位置相同时，也就是i和有边界相同时，记录答案，同时更新下一个左边界。 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { /** * 合并区间 * 1 遍历 s，计算字母 c 在 s 中的最后出现的下标 last[c]。 * 2 初始化当前正在合并的区间左右端点 start=0, end=0。 * 3 再次遍历 s，由于当前区间必须包含所有 s[i]，所以用 last[s[i]] 更新区间右端点 end 的最大值。 * 4 如果发现 end=i，那么当前区间合并完毕，把区间长度 end−start+1 加入答案。然后更新 start=i+1 作为下一个区间的左端点。 * 5 遍历完毕，返回答案。 */ public List\u0026lt;Integer\u0026gt; partitionLabels(String s) { int n = s.length(); // 存放这个字母在串中最后的下标 int[] last = new int[26]; // 这个数组是保存字母对应的下标 for (int i = 0; i \u0026lt; n; i++) { // 计算下标，放入last last[s.charAt(i) - \u0026#39;a\u0026#39;] = i; } List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int start = 0, end = 0; for (int i = 0; i \u0026lt; n; i++) { // i增加，如果遇到新的字母，他所在区间的最后下标会变更大 // 则更新当前区间的右端点为最大的右边界 end = Math.max(end, last[s.charAt(i) - \u0026#39;a\u0026#39;]); // 如果i遍历到当前区间右端点 // 说明没有新的字母出现了，区间内的所有字母的都不会出现在右侧了 // 可以开始算下一个区间，更新start if (i == end) { // 这个区间加入答案 ans.add(end - start + 1); // 从下一个区间开始 start = i + 1; } } return ans; } } 时间复杂度：$O(n)$ 空间复杂度：$O(∣Σ∣)$，其中 ∣Σ∣ 是字符集合的大小，本题字符均为小写字母，所以 ∣Σ∣=26。 ","permalink":"https://Xloading-919.github.io/zh/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/","summary":"\u003ch2 id=\"15-三数之和\"\u003e\u003ca href=\"https://leetcode.cn/problems/3sum/\"\u003e15. 三数之和\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e要求：找到和为0的三个数的组合，三个数不能重复。\u003c/p\u003e\n\u003ch3 id=\"思路排序双指针求和\"\u003e思路：排序双指针求和\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e这里因为不要求下标，只需要记录数值，所以可以排序打乱，先排序\u003c/li\u003e\n\u003cli\u003e三个数，可以先固定一个数在最左边，另外两个数在后面的部分使用双指针求得\u003c/li\u003e\n\u003cli\u003e遍历每个位置作为最左边得数，得到所有答案\u003c/li\u003e\n\u003cli\u003e最优就是$O(n^2)$复杂度了\u003c/li\u003e\n\u003cli\u003e要求不能重复，\n\u003col\u003e\n\u003cli\u003e外层遍历最左边的数时，跳过和前一次遍历相同的数\u003c/li\u003e\n\u003cli\u003e内层遍历时，在和为0时，两个指针指向的数收缩时也要跳过相同的数值\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e代码：\u003c/p\u003e","title":"数组双指针"},{"content":"3. 无重复字符的最长子串 要求：要找到最长的子串的长度，且要求不包含重复字符\n思路 使用滑动窗口双指针，右指针遍历，左指针控制左边界，用于计算最大长度 使用map记录已经出现过的元素和其位置。初始化窗口边界，右边界向后遍历并记录达到的最长窗口长度，当遇到重复元素，则把左边界移动到重复元素上一次出现位置之后（即跳过旧的重复元素） 注意窗口内出现重复只可能有一个重复，所以如果l提前右移过且已经移动到当前重复元素的后边，l不加1 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int l = 0, r = 0; r \u0026lt; n; r++){ char c = s.charAt(r); if(map.containsKey(c)){ //因为l表示不重复的第一个元素，所以是当前重复元素加1 //且，这里需要使得l为满足窗口内不重复的最右侧值 //如果只取当前重复值的下一个位置 //可能这个重复元素是很早（左侧）的元素 // 还可能有其他的重复元素，使得l提前右移过 //而现在的l已经因为其他元素重复在后边了 // 如果还取小的值，就跑回前面了 //所以要取下标最大即最右侧的值 l = Math.max(map.get(c) + 1, l); } ans = Math.max(ans, r - l + 1); // 把重复的位置覆盖为最新的 map.put(c, r); } return ans; } } 时间复杂度：O(n) 空间复杂度：O(1)，这里的map记录的是字符出现的次数，字符总共127个 1. 两数之和 要求：找到和为目标值的两个数的下标\n思路1 这里需要下标，而不是数。所以不能排序后用相向双指针 使用map记录已经遍历过的数 移项转换问题，一边遍历一边看是否在map中有另一个值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int[] twoSum(int[] nums, int target) { int[] ans = new int[2]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { ans[0] = i; ans[1] = map.get(target - nums[i]); return ans; } map.put(nums[i], i); } return ans; } } 时间复杂度O(n) 空间复杂度O(n) 思路2 不用map的方法。 需要一个二维数组额外记录数值和下标的对应关系 先排序，使用双指针解决 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int[] twoSum(int[] nums, int target) { int n = nums.length; // 用一个二维数组记录下标和值 int[][] pair = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { pair[i][0] = nums[i]; pair[i][1] = i; } // 对二维数组排序 Arrays.sort(pair, (a, b) -\u0026gt; (a[0] - b[0])); // 双指针找到和为target的两个数 int i = 0; int j = n - 1; while (i \u0026lt; j) { int x = pair[i][0] + pair[j][0]; if (x \u0026gt; target) { j--; } else if (x \u0026lt; target) { i++; } else { return new int[]{pair[i][1], pair[j][1]}; } } return new int[]{0, 0}; } } 时间复杂度：O(nlogn)，大头是排序时间 空间复杂度：O(n) 76. 最小覆盖子串 要求：找到能够涵盖所有目标串字符的最短子串\n思路 通过哈希表记录目标子串每个字符出现的次数，使用一个less变量，记录源串和目标串之间差多少种字符，只有当这一种字符出现的次数大于等于目标串中出现的次数时，less才-1 使用同向双指针 如果在遍历中，less为0，说明现在已经可以涵盖了，可以开始收缩左边界 收缩时，判断less变化，如果less不符合条件，再继续遍历 注意：初始化最小窗口(-1, s.length())，最后根据start判断是否有符合条件的子串 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public String minWindow(String s, String t) { int[] scnt = new int[128]; int[] tcnt = new int[128]; int less = 0; for (char c : t.toCharArray()) { if (tcnt[c] == 0) { less++; } tcnt[c]++; } int left = 0; int right = 0; int start = -1; int end = s.length(); while (right \u0026lt; s.length()) { char x = s.charAt(right); scnt[x]++; if (scnt[x] == tcnt[x]) { less--; } while (less == 0) { if (end - start \u0026gt; right - left) { start = left; end = right; } x = s.charAt(left); scnt[x]--; left++; if (tcnt[x] \u0026gt; scnt[x]) { less++; } } right++; } return start \u0026lt; 0 ? \u0026#34;\u0026#34; : s.substring(start, end + 1); } } 时间复杂度：O(m+n) 或 O(m+n+∣Σ∣)，其中 m 为 s 的长度，n 为 t 的长度，∣Σ∣=128。注意 left 只会增加不会减少，二重循环的时间复杂度为 O(m)。使用哈希表写法的时间复杂度为 O(m+n)，数组写法的时间复杂度为 O(m+n+∣Σ∣)。 空间复杂度：O(∣Σ∣)。如果创建了大小为 128 的数组，则 ∣Σ∣=128。 560. 和为 K 的子数组 要求：找到和为k的子数组的个数\n思路 子数组的和等于两个前缀数组的差值 移项解答 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int subarraySum(int[] nums, int k) { int ans = 0; int n = nums.length; // 子数组和等于前缀和数组之差 // 差为k：s[j] - s[i] = k -\u0026gt; s[i] = s[j] - k // 参考两数之和，移项后 // 一边枚举右边j // 一边用哈希表统计左边有多少个满足条件的i int[] s = new int[n + 1]; // 前缀和 for (int i = 0; i \u0026lt; n; i++) { s[i + 1] = s[i] + nums[i]; } Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int sj : s) { ans += map.getOrDefault(sj - k, 0); // 看有没有对应值 if (!map.containsKey(sj)) { // 把当前值放入map中 map.put(sj, 1); } else { map.put(sj, map.get(sj) + 1); } } return ans; } } 时间复杂度：O(n) 空间复杂度：O(n) 347. 前 K 个高频元素 要求：找到一个数组中出现频率前k高的所有元素。也就是重复次数最高的前k个数。\n思路1⭐ 首先用map记录下来每个数出现的次数 使用桶排序，记录每个数出现的次数（作为下标）和对应的所有数值 倒序遍历桶数组，取k个最高次数的数值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int[] topKFrequent(int[] nums, int k) { // 第一步，统计每个元素出现次数 Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int x : nums) { map.put(x, map.getOrDefault(x, 0) + 1); } int maxmap = Collections.max(map.values()); // 用于确定桶的大小 // 第二步，把出现次数相同的元素放到同一个桶中 // 创建“桶数组”（索引 = 出现次数，值 = 该次数对应的所有数字） // 比如：次数=3的数字都放在 buckets[3] 里 List\u0026lt;Integer\u0026gt;[] buckets = new ArrayList[maxmap + 1]; Arrays.setAll(buckets, i -\u0026gt; new ArrayList\u0026lt;\u0026gt;()); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; e : map.entrySet()) { buckets[e.getValue()].add(e.getKey()); } // 第三步，倒序遍历buckets，把出现次数前K大的元素加入答案 int[] ans = new int[k]; int cnt = 0; for (int i = maxmap; i \u0026gt;= 0; i--) { for (int x : buckets[i]) { // 从maxmap开始，加入出现次数最多的数 ans[cnt++] = x; } if (cnt == k) break; // 如果已经有了k个，退出 } return ans; } } 时间复杂度：O(n) 空间复杂度：O(n) 思路2 还是map记录下来每个数出现的次数 使用小顶堆，添加元素组合（数值和次数），按照次数排序，堆顶最小 遍历添加map中元素到堆中，当堆大小等于k时，可以判断当前元素出现的次数是否比堆顶更多 如果更多，说明当前元素更高频，加入堆中，堆顶移除 最后堆中剩下的就是k个次数最多的元素 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int x : nums) { map.put(x, map.getOrDefault(x, 0) + 1); } PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; (a[1] - b[1])); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; e : map.entrySet()) { int num = e.getKey(); int count = e.getValue(); if (q.size() == k) { if (count \u0026gt; q.peek()[1]) { q.poll(); q.offer(new int[]{num, count}); } } else { q.offer(new int[]{num, count}); } } int[] ans = new int[k]; for (int i = 0; i \u0026lt; k; i++) { ans[i] = q.poll()[0]; } return ans; } } 时间复杂度：O(nlogk)，每次操作堆需要O(logk)的时间，n次 空间复杂度：O(n) ","permalink":"https://Xloading-919.github.io/zh/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"\u003ch2 id=\"3-无重复字符的最长子串\"\u003e\u003ca href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\"\u003e3. 无重复字符的最长子串\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e要求：要找到最长的子串的长度，且要求不包含重复字符\u003c/p\u003e\n\u003ch3 id=\"思路\"\u003e思路\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e使用滑动窗口双指针，右指针遍历，左指针控制左边界，用于计算最大长度\u003c/li\u003e\n\u003cli\u003e使用map记录已经出现过的元素和其位置。初始化窗口边界，右边界向后遍历并记录达到的最长窗口长度，当遇到重复元素，则\u003cstrong\u003e把左边界移动到重复元素上一次出现位置之后\u003c/strong\u003e（即跳过旧的重复元素）\u003c/li\u003e\n\u003cli\u003e注意窗口内出现重复只可能有一个重复，所以如果l提前右移过且已经移动到当前重复元素的后边，l不加1\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e代码：\u003c/p\u003e","title":"哈希表"},{"content":"systemctl 是 systemd 的核心控制命令，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\n🧩 一、基本命令分类总览 类别 常用命令 作用 服务管理 start / stop / restart / reload / status 控制服务运行状态 开机自启 enable / disable / is-enabled 控制是否随系统启动 系统状态 list-units / list-unit-files / is-active / is-failed 查看单元运行状态 系统控制 reboot / poweroff / halt / suspend / default / isolate 控制系统运行级别 配置管理 daemon-reload / edit / cat / show 刷新或查看 unit 配置 日志与诊断 list-timers / show / status 查看定时器与服务详情 ⚙️ 二、服务管理类命令（最常用） 命令 示例 说明 start systemctl start nginx 启动服务 stop systemctl stop nginx 停止服务 restart systemctl restart nginx 重启服务 reload systemctl reload nginx 重新加载配置，不中断服务（支持的服务才行） status systemctl status nginx 查看服务运行状态 💡 提示：\n可以加 -l 显示完整日志，如：systemctl status nginx -l\n⚡ 三、开机自启管理 命令 示例 说明 enable systemctl enable nginx 设置开机自启（创建符号链接） disable systemctl disable nginx 取消开机自启 is-enabled systemctl is-enabled nginx 查看是否开机自启 mask systemctl mask nginx 屏蔽服务（完全禁止启动） unmask systemctl unmask nginx 解除屏蔽 🧠 四、查看系统服务状态 命令 说明 systemctl list-units 查看当前激活（active）的服务 systemctl list-units --type=service 仅显示服务类型 systemctl list-unit-files 查看所有服务文件（包括已禁用的） systemctl is-active nginx 判断某服务是否正在运行 systemctl is-failed nginx 判断是否启动失败 💻 五、系统运行级别管理（替代旧的 init、runlevel） 命令 说明 systemctl isolate multi-user.target 切换到多用户模式（类似 runlevel 3） systemctl isolate graphical.target 切换到图形界面模式（类似 runlevel 5） systemctl get-default 查看默认启动级别 systemctl set-default multi-user.target 设置默认启动级别为多用户模式 🔁 六、系统控制命令 命令 说明 systemctl reboot 重启系统 systemctl poweroff 关机 systemctl halt 停止所有 CPU systemctl suspend 挂起 systemctl hibernate 休眠 systemctl rescue 进入单用户救援模式 ⚙️ 七、配置相关命令 命令 说明 systemctl daemon-reload 重新加载 systemd 配置（修改 unit 文件后必须执行） systemctl edit nginx 编辑服务配置（推荐） systemctl cat nginx 查看服务文件内容 systemctl show nginx 查看服务详细属性 systemctl reset-failed 重置失败状态（清空 is-failed 记录） ⏰ 八、定时器管理（systemd timer） 命令 说明 systemctl list-timers 查看当前激活的定时器 systemctl list-timers --all 查看所有定时器（包括未激活的） ✅ 九、实用组合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 # 启动 nginx 并设置为开机自启 systemctl start nginx systemctl enable nginx # 查看 nginx 状态 systemctl status nginx # 修改 nginx unit 文件后重新加载 systemctl daemon-reload systemctl restart nginx # 禁止 nginx 启动（完全锁定） systemctl mask nginx 🧭 十、总结一句话： systemctl 是 systemd 的统一控制接口，\n可以启动、停止、重载、开机自启、查看状态、修改配置、切换运行级别——\n几乎替代了旧时代的 service、chkconfig、init 等所有命令。\n","permalink":"https://Xloading-919.github.io/zh/systemctl%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/","summary":"\u003cp\u003e\u003ccode\u003esystemctl\u003c/code\u003e 是 \u003cstrong\u003esystemd 的核心控制命令\u003c/strong\u003e，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\u003c/p\u003e\n\u003ch2 id=\"-一基本命令分类总览\"\u003e🧩 一、基本命令分类总览\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e类别\u003c/th\u003e\n          \u003cth\u003e常用命令\u003c/th\u003e\n          \u003cth\u003e作用\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e服务管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003estart\u003c/code\u003e / \u003ccode\u003estop\u003c/code\u003e / \u003ccode\u003erestart\u003c/code\u003e / \u003ccode\u003ereload\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e开机自启\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eenable\u003c/code\u003e / \u003ccode\u003edisable\u003c/code\u003e / \u003ccode\u003eis-enabled\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制是否随系统启动\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统状态\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-units\u003c/code\u003e / \u003ccode\u003elist-unit-files\u003c/code\u003e / \u003ccode\u003eis-active\u003c/code\u003e / \u003ccode\u003eis-failed\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看单元运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统控制\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ereboot\u003c/code\u003e / \u003ccode\u003epoweroff\u003c/code\u003e / \u003ccode\u003ehalt\u003c/code\u003e / \u003ccode\u003esuspend\u003c/code\u003e / \u003ccode\u003edefault\u003c/code\u003e / \u003ccode\u003eisolate\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制系统运行级别\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e配置管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003edaemon-reload\u003c/code\u003e / \u003ccode\u003eedit\u003c/code\u003e / \u003ccode\u003ecat\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e刷新或查看 unit 配置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e日志与诊断\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-timers\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看定时器与服务详情\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-二服务管理类命令最常用\"\u003e⚙️ 二、服务管理类命令（最常用）\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e命令\u003c/th\u003e\n          \u003cth\u003e示例\u003c/th\u003e\n          \u003cth\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl start nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e启动服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estop\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl stop nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e停止服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003erestart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl restart nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重启服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003ereload\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl reload nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重新加载配置，不中断服务（支持的服务才行）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estatus\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl status nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 提示：\u003cbr\u003e\n可以加 \u003ccode\u003e-l\u003c/code\u003e 显示完整日志，如：\u003ccode\u003esystemctl status nginx -l\u003c/code\u003e\u003c/p\u003e","title":"Systemctl命令简记"},{"content":"总览 下面是主要排序算法的性能表现：\nn：表示待排序的数据量 k：表示桶的个数 稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变 不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变 排序算法 时间复杂度（平均） 时间复杂度（最差） 时间复杂度（最好） 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 内部排序 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 希尔排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ 外部排序 稳定 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$ 内部排序 不稳定 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 计数排序 $O(n + k)$ $O(n + k)$ $O(n + k)$ $O(k)$ 外部排序 稳定 桶排序 $O(n + k)$ $O(n^2)$ $O(n + k)$ $O(n + k)$ 外部排序 稳定 基数排序 $O(n \\times k)$ $O(n \\times k)$ $O(n \\times k)$ $O(n + k)$ 外部排序 稳定 分类 ","permalink":"https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"总览\"\u003e总览\u003c/h2\u003e\n\u003cp\u003e下面是主要排序算法的性能表现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003en：表示待排序的数据量\u003c/li\u003e\n\u003cli\u003ek：表示桶的个数\u003c/li\u003e\n\u003cli\u003e稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变\u003c/li\u003e\n\u003cli\u003e不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e排序算法\u003c/th\u003e\n          \u003cth\u003e时间复杂度（平均）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最差）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最好）\u003c/th\u003e\n          \u003cth\u003e空间复杂度\u003c/th\u003e\n          \u003cth\u003e排序方式\u003c/th\u003e\n          \u003cth\u003e稳定性\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e冒泡排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e选择排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e插入排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e希尔排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e归并排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e快速排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(\\log n)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e堆排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e计数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e桶排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e基数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"分类\"\u003e分类\u003c/h2\u003e\n\u003ccenter\u003e\u003cimg src=\"img/排序算法分类.png\" width=\"60%\" /\u003e\u003c/center\u003e","title":"十大排序算法总结"},{"content":"为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n进程：操作系统资源分配的单位。一个程序就是一个进程 线程：CPU调度的单位，运行在进程内部，共享进程的资源 协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。 内核态和用户态 根据进程访问资源的特点，把进程在系统上的运行分为两个级别：\n用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源 内核态：内核态的进程可以访问所有硬件资源 两种状态的切换有三种方式：\n系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。 中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。 异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。 线程状态 Java的线程在生命周期中有6种状态：\nnew：初始状态，线程刚创建还没有start runnable：运行状态，调用start blocked：阻塞状态，等待锁释放 waiting：等待状态，等待通知或中断唤醒，然后等待锁 time_waiting：超时等待状态，指定时间后返回，如果是obj.wait(timeout)，还需要等待锁，如果是Thread.sleep(timeout) 或 join(timeout)，不需要等待锁。 terminated：终止状态，线程运行完毕 线程上下文切换 线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。\n线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。\n线程安全是什么 线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。\n可以从三个要素来保证线程安全：\n原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。 可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。 有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。 死锁 死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。\n死锁需要四个条件：\n互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。 请求与保持条件：线程对于已经获取的资源不会放弃。 不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。 循环等待条件：多个线程依次循环等待资源。 预防死锁方法：\n破坏请求与保持条件：一次性申请所有资源。 破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。 破坏循环等待条件：按顺序申请资源，反序释放。 ","permalink":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"为什么要多线程\"\u003e为什么要多线程\u003c/h2\u003e\n\u003cp\u003e多线程可以：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。\u003c/li\u003e\n\u003cli\u003e提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。\u003c/li\u003e\n\u003cli\u003e提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"并行与并发\"\u003e并行与并发\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e并行，是多核CPU上的多任务处理，是同一时间同时执行\u003c/li\u003e\n\u003cli\u003e并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"互斥与同步\"\u003e互斥与同步\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区\u003c/li\u003e\n\u003cli\u003e同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行\u003c/li\u003e\n\u003cli\u003e通过锁或者信号量机制实现。\n\u003col\u003e\n\u003cli\u003e信号量：\n\u003col\u003e\n\u003cli\u003ep操作：进入临界区前，将资源数量减1，可能阻塞\u003c/li\u003e\n\u003cli\u003ev操作：离开临界区后，将资源数量加1，不会阻塞\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"进程线程协程\"\u003e进程、线程、协程\u003c/h2\u003e\n\u003cp\u003e这是三种并发执行单元：\u003c/p\u003e","title":"多线程基础"},{"content":" 这里尝试写一个博客\n","permalink":"https://Xloading-919.github.io/zh/about/","summary":"\u003c!-- more --\u003e\n\u003cp\u003e这里尝试写一个博客\u003c/p\u003e","title":"关于"}]