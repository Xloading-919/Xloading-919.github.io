[{"content":"systemctl 是 systemd 的核心控制命令，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\n🧩 一、基本命令分类总览 类别 常用命令 作用 服务管理 start / stop / restart / reload / status 控制服务运行状态 开机自启 enable / disable / is-enabled 控制是否随系统启动 系统状态 list-units / list-unit-files / is-active / is-failed 查看单元运行状态 系统控制 reboot / poweroff / halt / suspend / default / isolate 控制系统运行级别 配置管理 daemon-reload / edit / cat / show 刷新或查看 unit 配置 日志与诊断 list-timers / show / status 查看定时器与服务详情 ⚙️ 二、服务管理类命令（最常用） 命令 示例 说明 start systemctl start nginx 启动服务 stop systemctl stop nginx 停止服务 restart systemctl restart nginx 重启服务 reload systemctl reload nginx 重新加载配置，不中断服务（支持的服务才行） status systemctl status nginx 查看服务运行状态 💡 提示：\n可以加 -l 显示完整日志，如：systemctl status nginx -l\n⚡ 三、开机自启管理 命令 示例 说明 enable systemctl enable nginx 设置开机自启（创建符号链接） disable systemctl disable nginx 取消开机自启 is-enabled systemctl is-enabled nginx 查看是否开机自启 mask systemctl mask nginx 屏蔽服务（完全禁止启动） unmask systemctl unmask nginx 解除屏蔽 🧠 四、查看系统服务状态 命令 说明 systemctl list-units 查看当前激活（active）的服务 systemctl list-units --type=service 仅显示服务类型 systemctl list-unit-files 查看所有服务文件（包括已禁用的） systemctl is-active nginx 判断某服务是否正在运行 systemctl is-failed nginx 判断是否启动失败 💻 五、系统运行级别管理（替代旧的 init、runlevel） 命令 说明 systemctl isolate multi-user.target 切换到多用户模式（类似 runlevel 3） systemctl isolate graphical.target 切换到图形界面模式（类似 runlevel 5） systemctl get-default 查看默认启动级别 systemctl set-default multi-user.target 设置默认启动级别为多用户模式 🔁 六、系统控制命令 命令 说明 systemctl reboot 重启系统 systemctl poweroff 关机 systemctl halt 停止所有 CPU systemctl suspend 挂起 systemctl hibernate 休眠 systemctl rescue 进入单用户救援模式 ⚙️ 七、配置相关命令 命令 说明 systemctl daemon-reload 重新加载 systemd 配置（修改 unit 文件后必须执行） systemctl edit nginx 编辑服务配置（推荐） systemctl cat nginx 查看服务文件内容 systemctl show nginx 查看服务详细属性 systemctl reset-failed 重置失败状态（清空 is-failed 记录） ⏰ 八、定时器管理（systemd timer） 命令 说明 systemctl list-timers 查看当前激活的定时器 systemctl list-timers --all 查看所有定时器（包括未激活的） ✅ 九、实用组合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 # 启动 nginx 并设置为开机自启 systemctl start nginx systemctl enable nginx # 查看 nginx 状态 systemctl status nginx # 修改 nginx unit 文件后重新加载 systemctl daemon-reload systemctl restart nginx # 禁止 nginx 启动（完全锁定） systemctl mask nginx 🧭 十、总结一句话： systemctl 是 systemd 的统一控制接口，\n可以启动、停止、重载、开机自启、查看状态、修改配置、切换运行级别——\n几乎替代了旧时代的 service、chkconfig、init 等所有命令。\n","permalink":"https://Xloading-919.github.io/zh/systemctl%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/","summary":"\u003cp\u003e\u003ccode\u003esystemctl\u003c/code\u003e 是 \u003cstrong\u003esystemd 的核心控制命令\u003c/strong\u003e，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\u003c/p\u003e\n\u003ch2 id=\"-一基本命令分类总览\"\u003e🧩 一、基本命令分类总览\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e类别\u003c/th\u003e\n          \u003cth\u003e常用命令\u003c/th\u003e\n          \u003cth\u003e作用\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e服务管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003estart\u003c/code\u003e / \u003ccode\u003estop\u003c/code\u003e / \u003ccode\u003erestart\u003c/code\u003e / \u003ccode\u003ereload\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e开机自启\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eenable\u003c/code\u003e / \u003ccode\u003edisable\u003c/code\u003e / \u003ccode\u003eis-enabled\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制是否随系统启动\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统状态\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-units\u003c/code\u003e / \u003ccode\u003elist-unit-files\u003c/code\u003e / \u003ccode\u003eis-active\u003c/code\u003e / \u003ccode\u003eis-failed\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看单元运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统控制\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ereboot\u003c/code\u003e / \u003ccode\u003epoweroff\u003c/code\u003e / \u003ccode\u003ehalt\u003c/code\u003e / \u003ccode\u003esuspend\u003c/code\u003e / \u003ccode\u003edefault\u003c/code\u003e / \u003ccode\u003eisolate\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制系统运行级别\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e配置管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003edaemon-reload\u003c/code\u003e / \u003ccode\u003eedit\u003c/code\u003e / \u003ccode\u003ecat\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e刷新或查看 unit 配置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e日志与诊断\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-timers\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看定时器与服务详情\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-二服务管理类命令最常用\"\u003e⚙️ 二、服务管理类命令（最常用）\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e命令\u003c/th\u003e\n          \u003cth\u003e示例\u003c/th\u003e\n          \u003cth\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl start nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e启动服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estop\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl stop nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e停止服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003erestart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl restart nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重启服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003ereload\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl reload nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重新加载配置，不中断服务（支持的服务才行）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estatus\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl status nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 提示：\u003cbr\u003e\n可以加 \u003ccode\u003e-l\u003c/code\u003e 显示完整日志，如：\u003ccode\u003esystemctl status nginx -l\u003c/code\u003e\u003c/p\u003e","title":"Systemctl命令简记"},{"content":"总览 下面是主要排序算法的性能表现：\nn：表示待排序的数据量 k：表示桶的个数 稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变 不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变 排序算法 时间复杂度（平均） 时间复杂度（最差） 时间复杂度（最好） 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 内部排序 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 希尔排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ 外部排序 稳定 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$ 内部排序 不稳定 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 计数排序 $O(n + k)$ $O(n + k)$ $O(n + k)$ $O(k)$ 外部排序 稳定 桶排序 $O(n + k)$ $O(n^2)$ $O(n + k)$ $O(n + k)$ 外部排序 稳定 基数排序 $O(n \\times k)$ $O(n \\times k)$ $O(n \\times k)$ $O(n + k)$ 外部排序 稳定 分类 ","permalink":"https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"总览\"\u003e总览\u003c/h2\u003e\n\u003cp\u003e下面是主要排序算法的性能表现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003en：表示待排序的数据量\u003c/li\u003e\n\u003cli\u003ek：表示桶的个数\u003c/li\u003e\n\u003cli\u003e稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变\u003c/li\u003e\n\u003cli\u003e不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e排序算法\u003c/th\u003e\n          \u003cth\u003e时间复杂度（平均）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最差）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最好）\u003c/th\u003e\n          \u003cth\u003e空间复杂度\u003c/th\u003e\n          \u003cth\u003e排序方式\u003c/th\u003e\n          \u003cth\u003e稳定性\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e冒泡排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e选择排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e插入排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e希尔排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e归并排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e快速排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(\\log n)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e堆排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e计数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e桶排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e基数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"分类\"\u003e分类\u003c/h2\u003e\n\u003c!-- 推荐：如果图片放在 `static/img`，请在内容中使用网站根路径引用，构建后会位于网站根的 `/img/` 下 --\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png\"\u003e\u003c/p\u003e","title":"十大排序算法总结"},{"content":"为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n进程：操作系统资源分配的单位。一个程序就是一个进程 线程：CPU调度的单位，运行在进程内部，共享进程的资源 协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。 内核态和用户态 根据进程访问资源的特点，把进程在系统上的运行分为两个级别：\n用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源 内核态：内核态的进程可以访问所有硬件资源 两种状态的切换有三种方式：\n系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。 中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。 异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。 线程状态 Java的线程在生命周期中有6种状态：\nnew：初始状态，线程刚创建还没有start runnable：运行状态，调用start blocked：阻塞状态，等待锁释放 waiting：等待状态，等待通知或中断唤醒，然后等待锁 time_waiting：超时等待状态，指定时间后返回，如果是obj.wait(timeout)，还需要等待锁，如果是Thread.sleep(timeout) 或 join(timeout)，不需要等待锁。 terminated：终止状态，线程运行完毕 线程上下文切换 线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。\n线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。\n线程安全是什么 线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。\n可以从三个要素来保证线程安全：\n原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。 可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。 有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。 死锁 死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。\n死锁需要四个条件：\n互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。 请求与保持条件：线程对于已经获取的资源不会放弃。 不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。 循环等待条件：多个线程依次循环等待资源。 预防死锁方法：\n破坏请求与保持条件：一次性申请所有资源。 破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。 破坏循环等待条件：按顺序申请资源，反序释放。 ","permalink":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"为什么要多线程\"\u003e为什么要多线程\u003c/h2\u003e\n\u003cp\u003e多线程可以：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。\u003c/li\u003e\n\u003cli\u003e提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。\u003c/li\u003e\n\u003cli\u003e提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"并行与并发\"\u003e并行与并发\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e并行，是多核CPU上的多任务处理，是同一时间同时执行\u003c/li\u003e\n\u003cli\u003e并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"互斥与同步\"\u003e互斥与同步\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区\u003c/li\u003e\n\u003cli\u003e同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行\u003c/li\u003e\n\u003cli\u003e通过锁或者信号量机制实现。\n\u003col\u003e\n\u003cli\u003e信号量：\n\u003col\u003e\n\u003cli\u003ep操作：进入临界区前，将资源数量减1，可能阻塞\u003c/li\u003e\n\u003cli\u003ev操作：离开临界区后，将资源数量加1，不会阻塞\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"进程线程协程\"\u003e进程、线程、协程\u003c/h2\u003e\n\u003cp\u003e这是三种并发执行单元：\u003c/p\u003e","title":"多线程基础"},{"content":" 这里尝试写一个博客\n","permalink":"https://Xloading-919.github.io/zh/about/","summary":"\u003c!-- more --\u003e\n\u003cp\u003e这里尝试写一个博客\u003c/p\u003e","title":"关于"}]