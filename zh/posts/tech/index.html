<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术 | Xloading's Blog</title><meta name=keywords content><meta name=description content><meta name=author content="axing"><link rel=canonical href=https://Xloading-919.github.io/zh/posts/tech/><link crossorigin=anonymous href=/assets/css/stylesheet.60e9f0b6784df1409ba6f4029a0b1e6323395367cc36407f08f8538034fe128f.css integrity="sha256-YOnwtnhN8UCbpvQCmgseYyM5U2fMNkB/CPhTgDT+Eo8=" rel="preload stylesheet" as=style><link rel=icon href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=16x16 href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=32x32 href=https://Xloading-919.github.io/img/logo.jpg><link rel=apple-touch-icon href=https://Xloading-919.github.io/logo.jpg><link rel=mask-icon href=https://Xloading-919.github.io/logo.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://Xloading-919.github.io/zh/posts/tech/index.xml title=rss><link rel=alternate hreflang=zh href=https://Xloading-919.github.io/zh/posts/tech/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><style>body{font-family:lxgw wenkai,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head><body></body></html><meta property="og:url" content="https://Xloading-919.github.io/zh/posts/tech/"><meta property="og:site_name" content="Xloading's Blog"><meta property="og:title" content="技术"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="技术"><meta name=twitter:description content="这是一个纯粹的博客......"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://Xloading-919.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://Xloading-919.github.io/zh/posts/tech/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Xloading-919.github.io/zh/ accesskey=h title="Xloading's Blog (Alt + H)">Xloading's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Xloading-919.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://Xloading-919.github.io/zh/posts title=文章><span>文章</span></a></li><li><a href=https://Xloading-919.github.io/zh/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://Xloading-919.github.io/zh/tags title=标签><span>标签</span></a></li><li><a href=https://Xloading-919.github.io/zh/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://Xloading-919.github.io/zh/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://Xloading-919.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://Xloading-919.github.io/zh/posts/>所有文章</a></div><h1>技术</h1></header><div class=post-content></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>三个常见消息队列对比总结</h2></header><div class=entry-content><p>一、总体定位与设计 特性 Kafka RabbitMQ RocketMQ 诞生背景 LinkedIn 为了解决日志收集、高吞吐流式处理 AMQP 协议标准实现，追求可靠投递 阿里为电商高并发交易场景设计 定位 分布式日志系统 / 流式平台 消息代理（Broker） 分布式消息中间件（国产 Kafka 改良版） 核心目标 高吞吐、可扩展、可持久化 低延迟、可靠性、灵活路由 高可用、顺序消息、事务消息 使用场景 日志采集、大数据流、实时分析 异步任务、业务解耦、通知推送 分布式事务、订单支付、延迟/定时消息 二、架构模型对比 对比项 Kafka RabbitMQ RocketMQ 模型 发布-订阅（Pub/Sub） 生产者 → 交换机 (Exchange) → 队列 → 消费者 主题 (Topic) + 队列 (MessageQueue) 消息路由 由 producer 指定 partition 由 exchange 根据 routing key 路由 根据 hash 或 sharding key 路由到队列 存储 顺序写日志（磁盘 + PageCache） 内存优先，磁盘持久化 文件顺序写（CommitLog + ConsumeQueue） 通信模型 基于 TCP，Pull 模式 基于 AMQP，Push 模式 Pull + 长轮询 消息顺序 分区内有序 队列内有序 队列内严格有序（支持全局有序） 消息确认 Offset 提交 ACK 确认 ACK 确认 消息重试 / 死信 offset 回滚 死信队列（DLX） 死信队列 + 重试 Topic 消费模式 Consumer Group Queue/Topic + Exchange Consumer Group 扩展性 极强（分区水平扩展） 一般（受单机性能限制） 良好（多队列 + Broker 集群） 三、性能与特性对比 维度 Kafka RabbitMQ RocketMQ 吞吐量 ⭐⭐⭐⭐（百万级/s） ⭐⭐（万级/s） ⭐⭐⭐（十万级/s） 延迟 低中（mss） 极低（亚毫秒级） 低（ms 级） 可扩展性 极强（分区并行） 一般（垂直扩展为主） 强（Broker 可水平扩展） 持久化 高效（顺序写） 可选（影响性能） 高效（多队列索引） 消息可靠性 高（副本 + ISR） 高（ACK + 持久化） 高（异步双写、主从同步） 事务消息 一般（0.11+ 支持） 弱（需额外实现） 强（原生支持事务消息） 延迟消息 不支持（需外部插件） 需 TTL + DLX 实现 原生支持定时/延迟消息 顺序消息 分区内有序 队列内有序 原生支持严格顺序消息 消息过滤 Consumer 端过滤 Exchange 路由过滤 Tag + SQL 表达式过滤 四、设计机制差异（为什么 Kafka 吞吐量最高？） Kafka 关键机制 原理 顺序写磁盘 + PageCache 几乎等价内存写入速度 零拷贝（Zero Copy） 减少用户态/内核态切换 批量发送 + 压缩 减少网络 I/O 分区并行读写 天然支持水平扩展 简化确认机制（offset） 降低消息确认开销 五、典型应用场景推荐 场景 推荐消息队列 理由 大数据日志采集 / 实时分析 Kafka ✅ 高吞吐、分区并行、顺序写 订单/交易系统、支付事务 RocketMQ ✅ 支持事务消息、延迟消息 简单异步任务 / 通知推送 RabbitMQ ✅ 低延迟、易用、路由灵活 高可扩展日志系统 Kafka 分布式架构 多租户 SaaS、分布式事务 RocketMQ 支持事务与回查机制 IoT 实时上报、轻量级消息 RabbitMQ 协议成熟，延迟极低 Kafka：高吞吐、顺序写、适合日志与流式数据。
RabbitMQ：低延迟、协议丰富、适合可靠业务消息。
RocketMQ：国产增强版，兼顾吞吐与可靠性，支持事务与延迟消息。
...</p></div><footer class=entry-footer><span title='2025-10-29 22:54:51 +0800 +0800'>2025-10-29</span>&nbsp;·&nbsp;<span>3 分钟</span>&nbsp;·&nbsp;<span>axing</span></footer><a class=entry-link aria-label="post link to 三个常见消息队列对比总结" href=https://Xloading-919.github.io/zh/%E4%B8%89%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>单例模式几种实现方式</h2></header><div class=entry-content><p>单例模式是什么 单例模式是创建型设计模式的一种，保证一个类只有一个实例，并提供一个全局访问点。 常用于全局共享资源，比如配置管理、连接池、日志对象。 作用 可以节省资源，避免频繁创建销毁对象，占用内存或系统资源 提供统一的访问入口，方便管理 保证全局只有一个对象，避免状态不一致 实现方式 饿汉式（类加载时就创建） 1 2 3 4 5 6 7 8 9 public class Singleton { // 这里要用final，初始化后不再修改 private static final Singleton instance = new Singleton(); private Singleton () {} // 设置私有访问权限的构造方法，防止外部调用 // 设置静态方法，提供全局类名访问方式 public static Singleton getInstance() { return instance; } } 优点：线程安全（JVM保证类加载时只执行一次） 缺点：类加载就创建，可能浪费资源 懒汉式（第一次用再加载） 1 2 3 4 5 6 7 8 9 10 11 public class Singleton { private static Singleton instance; private Singleton () {} // 这里需要加锁，每次只允许第一个创建或者获取 public static synchronized Singleton getInstace () { if (intstance == null) { // 判断是否已经存在了 instance = new Singleton(); } return instance; } } 优点：延迟加载 缺点：每次加锁，性能差 双重检查锁（DCL）懒汉式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Singleton { // volatile 防止指令重排，保证对象初始化完整可见 // 比如，A已经进入调用了构造函数，但是还没初始化完成 // B这时候去判断instance不为空，但是返回得到的是一个半初始化对象 private static volatile Singleton instance; private Singleton () {} public static getInstance() { if (instance == null) { // 第一次检查（避免不必要的同步） synchronized (Singleton.class) { // 锁确保只有一个线程进入初始化段 if (instance == null) { // 第二次检查（防止重复创建） instance = new Singleton();// 创建并赋值 } } } return instance; // 返回单例引用 } } 优点：兼顾 性能（避免每次都加锁） 与 线程安全（只创建一次） 缺点：代码略显复杂。 volatile的两个作用 可见性：一个线程对 instance 的写（赋值）会被其他线程立即看到；没有 volatile，一个线程修改可能对其他线程不可见（在 CPU 缓存中滞留）。 禁止指令重排（防止“半初始化对象”）：new Singleton() 在字节码/机器指令层面可能被重排序成（分配内存 → 赋值引用 → 调用构造器），若发生这种重排，另一个线程可能在构造器还没执行完时看到 instance != null 并使用一个“尚未完整初始化”的对象。volatile 引入内存栅栏，使得写 instance 不会在对象构造完成之前被发布，从而避免这个问题。 静态内部类 1 2 3 4 5 6 7 8 9 10 public class Singleton { private Singleton() {} private static class Holder { // 通过静态内部类中的静态变量初始化实例 private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return Holder.instance; // 通过内部类获取 } } 第一次调用 getInstance() 方法时，需要使用到Holder.instance，于是JVM 会加载 Holder 类，加载Holder 类时，初始化静态变量，执行new Singleton()，成功创建。 后续调用getInstance() 时，Holder 已经加载过了，INSTANCE 已存在，直接返回即可。 为什么可用：类的初始化阶段（&lt;clinit>）是线程安全的，同一个类只会被加载和初始化一次。 枚举实现（最安全） 1 2 3 4 5 6 7 public enum Singleton { INSTANCE; // 这个方法就是在业务代码中，调用Singleton.INSTANCE获取单例对象后，调用的方法逻辑 // 调用时，都是用同一个实例调用的 public void doSomething() {} } 破坏单例 序列化 序列化会破坏非枚举单例模式：
...</p></div><footer class=entry-footer><span title='2025-10-28 16:17:23 +0800 +0800'>2025-10-28</span>&nbsp;·&nbsp;<span>4 分钟</span>&nbsp;·&nbsp;<span>axing</span></footer><a class=entry-link aria-label="post link to 单例模式几种实现方式" href=https://Xloading-919.github.io/zh/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Systemctl命令简记</h2></header><div class=entry-content><p>systemctl 是 systemd 的核心控制命令，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。
🧩 一、基本命令分类总览 类别 常用命令 作用 服务管理 start / stop / restart / reload / status 控制服务运行状态 开机自启 enable / disable / is-enabled 控制是否随系统启动 系统状态 list-units / list-unit-files / is-active / is-failed 查看单元运行状态 系统控制 reboot / poweroff / halt / suspend / default / isolate 控制系统运行级别 配置管理 daemon-reload / edit / cat / show 刷新或查看 unit 配置 日志与诊断 list-timers / show / status 查看定时器与服务详情 ⚙️ 二、服务管理类命令（最常用） 命令 示例 说明 start systemctl start nginx 启动服务 stop systemctl stop nginx 停止服务 restart systemctl restart nginx 重启服务 reload systemctl reload nginx 重新加载配置，不中断服务（支持的服务才行） status systemctl status nginx 查看服务运行状态 💡 提示：
可以加 -l 显示完整日志，如：systemctl status nginx -l
...</p></div><footer class=entry-footer><span title='2025-10-15 16:43:17 +0800 +0800'>2025-10-15</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>axing</span></footer><a class=entry-link aria-label="post link to Systemctl命令简记" href=https://Xloading-919.github.io/zh/systemctl%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>十大排序算法总结</h2></header><div class=entry-content><p>总览 下面是主要排序算法的性能表现：
n：表示待排序的数据量 k：表示桶的个数 稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变 不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变 排序算法 时间复杂度（平均） 时间复杂度（最差） 时间复杂度（最好） 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 内部排序 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 希尔排序 $O(n\log n)$ $O(n^2)$ $O(n\log n)$ $O(1)$ 内部排序 不稳定 归并排序 $O(n\log n)$ $O(n\log n)$ $O(n\log n)$ $O(n)$ 外部排序 稳定 快速排序 $O(n\log n)$ $O(n^2)$ $O(n\log n)$ $O(\log n)$ 内部排序 不稳定 堆排序 $O(n\log n)$ $O(n\log n)$ $O(n\log n)$ $O(1)$ 内部排序 不稳定 计数排序 $O(n + k)$ $O(n + k)$ $O(n + k)$ $O(k)$ 外部排序 稳定 桶排序 $O(n + k)$ $O(n^2)$ $O(n + k)$ $O(n + k)$ 外部排序 稳定 基数排序 $O(n \times k)$ $O(n \times k)$ $O(n \times k)$ $O(n + k)$ 外部排序 稳定 分类</p></div><footer class=entry-footer><span title='2025-10-09 15:22:50 +0800 +0800'>2025-10-09</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>axing</span></footer><a class=entry-link aria-label="post link to 十大排序算法总结" href=https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>多线程基础</h2></header><div class=entry-content><p>为什么要多线程 多线程可以：
充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：
...</p></div><footer class=entry-footer><span title='2025-10-03 15:53:17 +0800 +0800'>2025-10-03</span>&nbsp;·&nbsp;<span>4 分钟</span>&nbsp;·&nbsp;<span>axing</span></footer><a class=entry-link aria-label="post link to 多线程基础" href=https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://Xloading-919.github.io/zh/>Xloading's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>