[{"content":"总览 下面是主要排序算法的性能表现：\nn：表示待排序的数据量 k：表示桶的个数 稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变 不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变 排序算法 时间复杂度（平均） 时间复杂度（最差） 时间复杂度（最好） 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 内部排序 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 希尔排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ 外部排序 稳定 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$ 内部排序 不稳定 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 计数排序 $O(n + k)$ $O(n + k)$ $O(n + k)$ $O(k)$ 外部排序 稳定 桶排序 $O(n + k)$ $O(n^2)$ $O(n + k)$ $O(n + k)$ 外部排序 稳定 基数排序 $O(n \\times k)$ $O(n \\times k)$ $O(n \\times k)$ $O(n + k)$ 外部排序 稳定 分类 ","permalink":"https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"总览\"\u003e总览\u003c/h2\u003e\n\u003cp\u003e下面是主要排序算法的性能表现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003en：表示待排序的数据量\u003c/li\u003e\n\u003cli\u003ek：表示桶的个数\u003c/li\u003e\n\u003cli\u003e稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变\u003c/li\u003e\n\u003cli\u003e不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e排序算法\u003c/th\u003e\n          \u003cth\u003e时间复杂度（平均）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最差）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最好）\u003c/th\u003e\n          \u003cth\u003e空间复杂度\u003c/th\u003e\n          \u003cth\u003e排序方式\u003c/th\u003e\n          \u003cth\u003e稳定性\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e冒泡排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e选择排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e插入排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e希尔排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e归并排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e快速排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(\\log n)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e堆排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e计数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e桶排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e基数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"分类\"\u003e分类\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"../../../static/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png\"\u003e\u003c/p\u003e","title":"十大排序算法总结"},{"content":"## 为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n进程：操作系统资源分配的单位。一个程序就是一个进程 线程：CPU调度的单位，运行在进程内部，共享进程的资源 协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。 内核态和用户态 根据进程访问资源的特点，把进程在系统上的运行分为两个级别：\n用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源 内核态：内核态的进程可以访问所有硬件资源 两种状态的切换有三种方式：\n系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。 中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。 异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。 线程状态 Java的线程在生命周期中有6种状态：\nnew：初始状态，线程刚创建还没有start runnable：运行状态，调用start blocked：阻塞状态，等待锁释放 waiting：等待状态，等待通知或中断唤醒，然后等待锁 time_waiting：超时等待状态，指定时间后返回，如果是obj.wait(timeout)，还需要等待锁，如果是Thread.sleep(timeout) 或 join(timeout)，不需要等待锁。 terminated：终止状态，线程运行完毕 线程上下文切换 线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。\n线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。\n线程安全是什么 线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。\n可以从三个要素来保证线程安全：\n原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。 可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。 有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。 死锁 死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。\n死锁需要四个条件：\n互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。 请求与保持条件：线程对于已经获取的资源不会放弃。 不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。 循环等待条件：多个线程依次循环等待资源。 预防死锁方法：\n破坏请求与保持条件：一次性申请所有资源。 破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。 破坏循环等待条件：按顺序申请资源，反序释放。 ","permalink":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003cpre\u003e\u003ccode\u003e## 为什么要多线程\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多线程可以：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。\u003c/li\u003e\n\u003cli\u003e提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。\u003c/li\u003e\n\u003cli\u003e提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"并行与并发\"\u003e并行与并发\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e并行，是多核CPU上的多任务处理，是同一时间同时执行\u003c/li\u003e\n\u003cli\u003e并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"互斥与同步\"\u003e互斥与同步\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区\u003c/li\u003e\n\u003cli\u003e同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行\u003c/li\u003e\n\u003cli\u003e通过锁或者信号量机制实现。\n\u003col\u003e\n\u003cli\u003e信号量：\n\u003col\u003e\n\u003cli\u003ep操作：进入临界区前，将资源数量减1，可能阻塞\u003c/li\u003e\n\u003cli\u003ev操作：离开临界区后，将资源数量加1，不会阻塞\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"进程线程协程\"\u003e进程、线程、协程\u003c/h2\u003e\n\u003cp\u003e这是三种并发执行单元：\u003c/p\u003e","title":"多线程基础"},{"content":" 这里尝试写一个博客\n","permalink":"https://Xloading-919.github.io/zh/about/","summary":"\u003c!-- more --\u003e\n\u003cp\u003e这里尝试写一个博客\u003c/p\u003e","title":"关于"}]