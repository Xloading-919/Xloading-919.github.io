[{"content":"","permalink":"https://Xloading-919.github.io/zh/%E5%8F%8C%E6%8C%87%E9%92%88/","summary":"","title":"双指针"},{"content":"3. 无重复字符的最长子串 要求：要找到最长的子串的长度，且要求不包含重复字符\n思路 使用滑动窗口双指针，右指针遍历，左指针控制左边界，用于计算最大长度 使用map记录已经出现过的元素和其位置。初始化窗口边界，右边界向后遍历并记录达到的最长窗口长度，当遇到重复元素，则把左边界移动到重复元素上一次出现位置之后（即跳过旧的重复元素） 注意窗口内出现重复只可能有一个重复，所以如果l提前右移过且已经移动到当前重复元素的后边，l不加1 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int l = 0, r = 0; r \u0026lt; n; r++){ char c = s.charAt(r); if(map.containsKey(c)){ //因为l表示不重复的第一个元素，所以是当前重复元素加1 //且，这里需要使得l为满足窗口内不重复的最右侧值 //如果只取当前重复值的下一个位置 //可能这个重复元素是很早（左侧）的元素 // 还可能有其他的重复元素，使得l提前右移过 //而现在的l已经因为其他元素重复在后边了 // 如果还取小的值，就跑回前面了 //所以要取下标最大即最右侧的值 l = Math.max(map.get(c) + 1, l); } ans = Math.max(ans, r - l + 1); // 把重复的位置覆盖为最新的 map.put(c, r); } return ans; } } 时间复杂度：O(n) 空间复杂度：O(1)，这里的map记录的是字符出现的次数，字符总共127个 1. 两数之和 要求：找到和为目标值的两个数的下标\n思路1 这里需要下标，而不是数。所以不能排序后用相向双指针 使用map记录已经遍历过的数 移项转换问题，一边遍历一边看是否在map中有另一个值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int[] twoSum(int[] nums, int target) { int[] ans = new int[2]; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { ans[0] = i; ans[1] = map.get(target - nums[i]); return ans; } map.put(nums[i], i); } return ans; } } 时间复杂度O(n) 空间复杂度O(n) 思路2 不用map的方法。 需要一个二维数组额外记录数值和下标的对应关系 先排序，使用双指针解决 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int[] twoSum(int[] nums, int target) { int n = nums.length; // 用一个二维数组记录下标和值 int[][] pair = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { pair[i][0] = nums[i]; pair[i][1] = i; } // 对二维数组排序 Arrays.sort(pair, (a, b) -\u0026gt; (a[0] - b[0])); // 双指针找到和为target的两个数 int i = 0; int j = n - 1; while (i \u0026lt; j) { int x = pair[i][0] + pair[j][0]; if (x \u0026gt; target) { j--; } else if (x \u0026lt; target) { i++; } else { return new int[]{pair[i][1], pair[j][1]}; } } return new int[]{0, 0}; } } 时间复杂度：O(nlogn)，大头是排序时间 空间复杂度：O(n) 76. 最小覆盖子串 要求：找到能够涵盖所有目标串字符的最短子串\n思路 通过哈希表记录目标子串每个字符出现的次数，使用一个less变量，记录源串和目标串之间差多少种字符，只有当这一种字符出现的次数大于等于目标串中出现的次数时，less才-1 使用同向双指针 如果在遍历中，less为0，说明现在已经可以涵盖了，可以开始收缩左边界 收缩时，判断less变化，如果less不符合条件，再继续遍历 注意：初始化最小窗口(-1, s.length())，最后根据start判断是否有符合条件的子串 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public String minWindow(String s, String t) { int[] scnt = new int[128]; int[] tcnt = new int[128]; int less = 0; for (char c : t.toCharArray()) { if (tcnt[c] == 0) { less++; } tcnt[c]++; } int left = 0; int right = 0; int start = -1; int end = s.length(); while (right \u0026lt; s.length()) { char x = s.charAt(right); scnt[x]++; if (scnt[x] == tcnt[x]) { less--; } while (less == 0) { if (end - start \u0026gt; right - left) { start = left; end = right; } x = s.charAt(left); scnt[x]--; left++; if (tcnt[x] \u0026gt; scnt[x]) { less++; } } right++; } return start \u0026lt; 0 ? \u0026#34;\u0026#34; : s.substring(start, end + 1); } } 时间复杂度：O(m+n) 或 O(m+n+∣Σ∣)，其中 m 为 s 的长度，n 为 t 的长度，∣Σ∣=128。注意 left 只会增加不会减少，二重循环的时间复杂度为 O(m)。使用哈希表写法的时间复杂度为 O(m+n)，数组写法的时间复杂度为 O(m+n+∣Σ∣)。 空间复杂度：O(∣Σ∣)。如果创建了大小为 128 的数组，则 ∣Σ∣=128。 560. 和为 K 的子数组 要求：找到和为k的子数组的个数\n思路 子数组的和等于两个前缀数组的差值 移项解答 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int subarraySum(int[] nums, int k) { int ans = 0; int n = nums.length; // 子数组和等于前缀和数组之差 // 差为k：s[j] - s[i] = k -\u0026gt; s[i] = s[j] - k // 参考两数之和，移项后 // 一边枚举右边j // 一边用哈希表统计左边有多少个满足条件的i int[] s = new int[n + 1]; // 前缀和 for (int i = 0; i \u0026lt; n; i++) { s[i + 1] = s[i] + nums[i]; } Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int sj : s) { ans += map.getOrDefault(sj - k, 0); // 看有没有对应值 if (!map.containsKey(sj)) { // 把当前值放入map中 map.put(sj, 1); } else { map.put(sj, map.get(sj) + 1); } } return ans; } } 时间复杂度：O(n) 空间复杂度：O(n) 347. 前 K 个高频元素 要求：找到一个数组中出现频率前k高的所有元素。也就是重复次数最高的前k个数。\n思路1⭐ 首先用map记录下来每个数出现的次数 使用桶排序，记录每个数出现的次数（作为下标）和对应的所有数值 倒序遍历桶数组，取k个最高次数的数值 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int[] topKFrequent(int[] nums, int k) { // 第一步，统计每个元素出现次数 Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int x : nums) { map.put(x, map.getOrDefault(x, 0) + 1); } int maxmap = Collections.max(map.values()); // 用于确定桶的大小 // 第二步，把出现次数相同的元素放到同一个桶中 // 创建“桶数组”（索引 = 出现次数，值 = 该次数对应的所有数字） // 比如：次数=3的数字都放在 buckets[3] 里 List\u0026lt;Integer\u0026gt;[] buckets = new ArrayList[maxmap + 1]; Arrays.setAll(buckets, i -\u0026gt; new ArrayList\u0026lt;\u0026gt;()); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; e : map.entrySet()) { buckets[e.getValue()].add(e.getKey()); } // 第三步，倒序遍历buckets，把出现次数前K大的元素加入答案 int[] ans = new int[k]; int cnt = 0; for (int i = maxmap; i \u0026gt;= 0; i--) { for (int x : buckets[i]) { // 从maxmap开始，加入出现次数最多的数 ans[cnt++] = x; } if (cnt == k) break; // 如果已经有了k个，退出 } return ans; } } 时间复杂度：O(n) 空间复杂度：O(n) 思路2 还是map记录下来每个数出现的次数 使用小顶堆，添加元素组合（数值和次数），按照次数排序，堆顶最小 遍历添加map中元素到堆中，当堆大小等于k时，可以判断当前元素出现的次数是否比堆顶更多 如果更多，说明当前元素更高频，加入堆中，堆顶移除 最后堆中剩下的就是k个次数最多的元素 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int x : nums) { map.put(x, map.getOrDefault(x, 0) + 1); } PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; (a[1] - b[1])); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; e : map.entrySet()) { int num = e.getKey(); int count = e.getValue(); if (q.size() == k) { if (count \u0026gt; q.peek()[1]) { q.poll(); q.offer(new int[]{num, count}); } } else { q.offer(new int[]{num, count}); } } int[] ans = new int[k]; for (int i = 0; i \u0026lt; k; i++) { ans[i] = q.poll()[0]; } return ans; } } 时间复杂度：O(nlogk)，每次操作堆需要O(logk)的时间，n次 空间复杂度：O(n) ","permalink":"https://Xloading-919.github.io/zh/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"\u003ch2 id=\"3-无重复字符的最长子串\"\u003e\u003ca href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\"\u003e3. 无重复字符的最长子串\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e要求：要找到最长的子串的长度，且要求不包含重复字符\u003c/p\u003e\n\u003ch3 id=\"思路\"\u003e思路\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e使用滑动窗口双指针，右指针遍历，左指针控制左边界，用于计算最大长度\u003c/li\u003e\n\u003cli\u003e使用map记录已经出现过的元素和其位置。初始化窗口边界，右边界向后遍历并记录达到的最长窗口长度，当遇到重复元素，则\u003cstrong\u003e把左边界移动到重复元素上一次出现位置之后\u003c/strong\u003e（即跳过旧的重复元素）\u003c/li\u003e\n\u003cli\u003e注意窗口内出现重复只可能有一个重复，所以如果l提前右移过且已经移动到当前重复元素的后边，l不加1\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e代码：\u003c/p\u003e","title":"哈希表"},{"content":"systemctl 是 systemd 的核心控制命令，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\n🧩 一、基本命令分类总览 类别 常用命令 作用 服务管理 start / stop / restart / reload / status 控制服务运行状态 开机自启 enable / disable / is-enabled 控制是否随系统启动 系统状态 list-units / list-unit-files / is-active / is-failed 查看单元运行状态 系统控制 reboot / poweroff / halt / suspend / default / isolate 控制系统运行级别 配置管理 daemon-reload / edit / cat / show 刷新或查看 unit 配置 日志与诊断 list-timers / show / status 查看定时器与服务详情 ⚙️ 二、服务管理类命令（最常用） 命令 示例 说明 start systemctl start nginx 启动服务 stop systemctl stop nginx 停止服务 restart systemctl restart nginx 重启服务 reload systemctl reload nginx 重新加载配置，不中断服务（支持的服务才行） status systemctl status nginx 查看服务运行状态 💡 提示：\n可以加 -l 显示完整日志，如：systemctl status nginx -l\n⚡ 三、开机自启管理 命令 示例 说明 enable systemctl enable nginx 设置开机自启（创建符号链接） disable systemctl disable nginx 取消开机自启 is-enabled systemctl is-enabled nginx 查看是否开机自启 mask systemctl mask nginx 屏蔽服务（完全禁止启动） unmask systemctl unmask nginx 解除屏蔽 🧠 四、查看系统服务状态 命令 说明 systemctl list-units 查看当前激活（active）的服务 systemctl list-units --type=service 仅显示服务类型 systemctl list-unit-files 查看所有服务文件（包括已禁用的） systemctl is-active nginx 判断某服务是否正在运行 systemctl is-failed nginx 判断是否启动失败 💻 五、系统运行级别管理（替代旧的 init、runlevel） 命令 说明 systemctl isolate multi-user.target 切换到多用户模式（类似 runlevel 3） systemctl isolate graphical.target 切换到图形界面模式（类似 runlevel 5） systemctl get-default 查看默认启动级别 systemctl set-default multi-user.target 设置默认启动级别为多用户模式 🔁 六、系统控制命令 命令 说明 systemctl reboot 重启系统 systemctl poweroff 关机 systemctl halt 停止所有 CPU systemctl suspend 挂起 systemctl hibernate 休眠 systemctl rescue 进入单用户救援模式 ⚙️ 七、配置相关命令 命令 说明 systemctl daemon-reload 重新加载 systemd 配置（修改 unit 文件后必须执行） systemctl edit nginx 编辑服务配置（推荐） systemctl cat nginx 查看服务文件内容 systemctl show nginx 查看服务详细属性 systemctl reset-failed 重置失败状态（清空 is-failed 记录） ⏰ 八、定时器管理（systemd timer） 命令 说明 systemctl list-timers 查看当前激活的定时器 systemctl list-timers --all 查看所有定时器（包括未激活的） ✅ 九、实用组合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 # 启动 nginx 并设置为开机自启 systemctl start nginx systemctl enable nginx # 查看 nginx 状态 systemctl status nginx # 修改 nginx unit 文件后重新加载 systemctl daemon-reload systemctl restart nginx # 禁止 nginx 启动（完全锁定） systemctl mask nginx 🧭 十、总结一句话： systemctl 是 systemd 的统一控制接口，\n可以启动、停止、重载、开机自启、查看状态、修改配置、切换运行级别——\n几乎替代了旧时代的 service、chkconfig、init 等所有命令。\n","permalink":"https://Xloading-919.github.io/zh/systemctl%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/","summary":"\u003cp\u003e\u003ccode\u003esystemctl\u003c/code\u003e 是 \u003cstrong\u003esystemd 的核心控制命令\u003c/strong\u003e，用于管理系统服务、单元（unit）、启动目标、设备、挂载点等。\u003c/p\u003e\n\u003ch2 id=\"-一基本命令分类总览\"\u003e🧩 一、基本命令分类总览\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e类别\u003c/th\u003e\n          \u003cth\u003e常用命令\u003c/th\u003e\n          \u003cth\u003e作用\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e服务管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003estart\u003c/code\u003e / \u003ccode\u003estop\u003c/code\u003e / \u003ccode\u003erestart\u003c/code\u003e / \u003ccode\u003ereload\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e开机自启\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eenable\u003c/code\u003e / \u003ccode\u003edisable\u003c/code\u003e / \u003ccode\u003eis-enabled\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制是否随系统启动\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统状态\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-units\u003c/code\u003e / \u003ccode\u003elist-unit-files\u003c/code\u003e / \u003ccode\u003eis-active\u003c/code\u003e / \u003ccode\u003eis-failed\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看单元运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统控制\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ereboot\u003c/code\u003e / \u003ccode\u003epoweroff\u003c/code\u003e / \u003ccode\u003ehalt\u003c/code\u003e / \u003ccode\u003esuspend\u003c/code\u003e / \u003ccode\u003edefault\u003c/code\u003e / \u003ccode\u003eisolate\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e控制系统运行级别\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e配置管理\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003edaemon-reload\u003c/code\u003e / \u003ccode\u003eedit\u003c/code\u003e / \u003ccode\u003ecat\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e刷新或查看 unit 配置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e日志与诊断\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elist-timers\u003c/code\u003e / \u003ccode\u003eshow\u003c/code\u003e / \u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看定时器与服务详情\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"-二服务管理类命令最常用\"\u003e⚙️ 二、服务管理类命令（最常用）\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e命令\u003c/th\u003e\n          \u003cth\u003e示例\u003c/th\u003e\n          \u003cth\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl start nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e启动服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estop\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl stop nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e停止服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003erestart\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl restart nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重启服务\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003ereload\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl reload nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e重新加载配置，不中断服务（支持的服务才行）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003estatus\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esystemctl status nginx\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看服务运行状态\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 提示：\u003cbr\u003e\n可以加 \u003ccode\u003e-l\u003c/code\u003e 显示完整日志，如：\u003ccode\u003esystemctl status nginx -l\u003c/code\u003e\u003c/p\u003e","title":"Systemctl命令简记"},{"content":"总览 下面是主要排序算法的性能表现：\nn：表示待排序的数据量 k：表示桶的个数 稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变 不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变 排序算法 时间复杂度（平均） 时间复杂度（最差） 时间复杂度（最好） 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 内部排序 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 内部排序 稳定 希尔排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ 外部排序 稳定 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$ 内部排序 不稳定 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ 内部排序 不稳定 计数排序 $O(n + k)$ $O(n + k)$ $O(n + k)$ $O(k)$ 外部排序 稳定 桶排序 $O(n + k)$ $O(n^2)$ $O(n + k)$ $O(n + k)$ 外部排序 稳定 基数排序 $O(n \\times k)$ $O(n \\times k)$ $O(n \\times k)$ $O(n + k)$ 外部排序 稳定 分类 ","permalink":"https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"总览\"\u003e总览\u003c/h2\u003e\n\u003cp\u003e下面是主要排序算法的性能表现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003en：表示待排序的数据量\u003c/li\u003e\n\u003cli\u003ek：表示桶的个数\u003c/li\u003e\n\u003cli\u003e稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变\u003c/li\u003e\n\u003cli\u003e不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e排序算法\u003c/th\u003e\n          \u003cth\u003e时间复杂度（平均）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最差）\u003c/th\u003e\n          \u003cth\u003e时间复杂度（最好）\u003c/th\u003e\n          \u003cth\u003e空间复杂度\u003c/th\u003e\n          \u003cth\u003e排序方式\u003c/th\u003e\n          \u003cth\u003e稳定性\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e冒泡排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e选择排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e插入排序\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e希尔排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e归并排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e快速排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(\\log n)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e堆排序\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(n\\log n)$\u003c/td\u003e\n          \u003ctd\u003e$O(1)$\u003c/td\u003e\n          \u003ctd\u003e内部排序\u003c/td\u003e\n          \u003ctd\u003e不稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e计数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e桶排序\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n^2)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e基数排序\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n \\times k)$\u003c/td\u003e\n          \u003ctd\u003e$O(n + k)$\u003c/td\u003e\n          \u003ctd\u003e外部排序\u003c/td\u003e\n          \u003ctd\u003e稳定\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"分类\"\u003e分类\u003c/h2\u003e\n\u003ccenter\u003e\u003cimg src=\"img/排序算法分类.png\" width=\"60%\" /\u003e\u003c/center\u003e","title":"十大排序算法总结"},{"content":"为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n进程：操作系统资源分配的单位。一个程序就是一个进程 线程：CPU调度的单位，运行在进程内部，共享进程的资源 协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。 内核态和用户态 根据进程访问资源的特点，把进程在系统上的运行分为两个级别：\n用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源 内核态：内核态的进程可以访问所有硬件资源 两种状态的切换有三种方式：\n系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。 中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。 异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。 线程状态 Java的线程在生命周期中有6种状态：\nnew：初始状态，线程刚创建还没有start runnable：运行状态，调用start blocked：阻塞状态，等待锁释放 waiting：等待状态，等待通知或中断唤醒，然后等待锁 time_waiting：超时等待状态，指定时间后返回，如果是obj.wait(timeout)，还需要等待锁，如果是Thread.sleep(timeout) 或 join(timeout)，不需要等待锁。 terminated：终止状态，线程运行完毕 线程上下文切换 线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。\n线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。\n线程安全是什么 线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。\n可以从三个要素来保证线程安全：\n原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。 可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。 有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。 死锁 死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。\n死锁需要四个条件：\n互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。 请求与保持条件：线程对于已经获取的资源不会放弃。 不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。 循环等待条件：多个线程依次循环等待资源。 预防死锁方法：\n破坏请求与保持条件：一次性申请所有资源。 破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。 破坏循环等待条件：按顺序申请资源，反序释放。 ","permalink":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"为什么要多线程\"\u003e为什么要多线程\u003c/h2\u003e\n\u003cp\u003e多线程可以：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。\u003c/li\u003e\n\u003cli\u003e提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。\u003c/li\u003e\n\u003cli\u003e提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"并行与并发\"\u003e并行与并发\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e并行，是多核CPU上的多任务处理，是同一时间同时执行\u003c/li\u003e\n\u003cli\u003e并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"互斥与同步\"\u003e互斥与同步\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区\u003c/li\u003e\n\u003cli\u003e同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行\u003c/li\u003e\n\u003cli\u003e通过锁或者信号量机制实现。\n\u003col\u003e\n\u003cli\u003e信号量：\n\u003col\u003e\n\u003cli\u003ep操作：进入临界区前，将资源数量减1，可能阻塞\u003c/li\u003e\n\u003cli\u003ev操作：离开临界区后，将资源数量加1，不会阻塞\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"进程线程协程\"\u003e进程、线程、协程\u003c/h2\u003e\n\u003cp\u003e这是三种并发执行单元：\u003c/p\u003e","title":"多线程基础"},{"content":" 这里尝试写一个博客\n","permalink":"https://Xloading-919.github.io/zh/about/","summary":"\u003c!-- more --\u003e\n\u003cp\u003e这里尝试写一个博客\u003c/p\u003e","title":"关于"}]