<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Xloading&#39;s Blog</title>
    <link>https://Xloading-919.github.io/zh/</link>
    <description>Recent content on Xloading&#39;s Blog</description>
    <generator>Hugo -- 0.151.0</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 09 Oct 2025 15:22:50 +0800</lastBuildDate>
    <atom:link href="https://Xloading-919.github.io/zh/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>十大排序算法总结</title>
      <link>https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 09 Oct 2025 15:22:50 +0800</pubDate>
      <guid>https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;总览&#34;&gt;总览&lt;/h2&gt;
&lt;p&gt;下面是主要排序算法的性能表现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n：表示待排序的数据量&lt;/li&gt;
&lt;li&gt;k：表示桶的个数&lt;/li&gt;
&lt;li&gt;稳定：表示如果$A=B$相同，原本A和B在序列中的顺序不变&lt;/li&gt;
&lt;li&gt;不稳定：表示如果$A=B$相同，原本A和B在序列中的顺序可能会变&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;排序算法&lt;/th&gt;
          &lt;th&gt;时间复杂度（平均）&lt;/th&gt;
          &lt;th&gt;时间复杂度（最差）&lt;/th&gt;
          &lt;th&gt;时间复杂度（最好）&lt;/th&gt;
          &lt;th&gt;空间复杂度&lt;/th&gt;
          &lt;th&gt;排序方式&lt;/th&gt;
          &lt;th&gt;稳定性&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;冒泡排序&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n)$&lt;/td&gt;
          &lt;td&gt;$O(1)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;选择排序&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(1)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插入排序&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n)$&lt;/td&gt;
          &lt;td&gt;$O(1)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;希尔排序&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(1)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;归并排序&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n)$&lt;/td&gt;
          &lt;td&gt;外部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;快速排序&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(\log n)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;堆排序&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(n\log n)$&lt;/td&gt;
          &lt;td&gt;$O(1)$&lt;/td&gt;
          &lt;td&gt;内部排序&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;计数排序&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;$O(k)$&lt;/td&gt;
          &lt;td&gt;外部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;桶排序&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;$O(n^2)$&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;外部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;基数排序&lt;/td&gt;
          &lt;td&gt;$O(n \times k)$&lt;/td&gt;
          &lt;td&gt;$O(n \times k)$&lt;/td&gt;
          &lt;td&gt;$O(n \times k)$&lt;/td&gt;
          &lt;td&gt;$O(n + k)$&lt;/td&gt;
          &lt;td&gt;外部排序&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;../../../static/img/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>多线程基础</title>
      <link>https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 03 Oct 2025 15:53:17 +0800</pubDate>
      <guid>https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;pre&gt;&lt;code&gt;## 为什么要多线程
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多线程可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。&lt;/li&gt;
&lt;li&gt;提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。&lt;/li&gt;
&lt;li&gt;提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;并行与并发&#34;&gt;并行与并发&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;并行，是多核CPU上的多任务处理，是同一时间同时执行&lt;/li&gt;
&lt;li&gt;并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;互斥与同步&#34;&gt;互斥与同步&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区&lt;/li&gt;
&lt;li&gt;同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行&lt;/li&gt;
&lt;li&gt;通过锁或者信号量机制实现。
&lt;ol&gt;
&lt;li&gt;信号量：
&lt;ol&gt;
&lt;li&gt;p操作：进入临界区前，将资源数量减1，可能阻塞&lt;/li&gt;
&lt;li&gt;v操作：离开临界区后，将资源数量加1，不会阻塞&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;进程线程协程&#34;&gt;进程、线程、协程&lt;/h2&gt;
&lt;p&gt;这是三种并发执行单元：&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于</title>
      <link>https://Xloading-919.github.io/zh/about/</link>
      <pubDate>Tue, 16 Sep 2025 16:45:38 +0800</pubDate>
      <guid>https://Xloading-919.github.io/zh/about/</guid>
      <description>&lt;!-- more --&gt;
&lt;p&gt;这里尝试写一个博客&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
