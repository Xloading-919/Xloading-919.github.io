<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>多线程基础 | Xloading's Blog</title><meta name=keywords content="并发基础"><meta name=description content="## 为什么要多线程

多线程可以：

充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。
提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。
提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。

并行与并发

并行，是多核CPU上的多任务处理，是同一时间同时执行
并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现

互斥与同步

互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区
同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行
通过锁或者信号量机制实现。

信号量：

p操作：进入临界区前，将资源数量减1，可能阻塞
v操作：离开临界区后，将资源数量加1，不会阻塞





进程、线程、协程
这是三种并发执行单元："><meta name=author content="axing"><link rel=canonical href=https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.e96c0411e96e32ab7d742d54e63006f69a87f56077983fdf887c333876423dd9.css integrity="sha256-6WwEEeluMqt9dC1U5jAG9pqH9WB3mD/fiHwzOHZCPdk=" rel="preload stylesheet" as=style><link rel=icon href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=16x16 href=https://Xloading-919.github.io/img/logo.jpg><link rel=icon type=image/png sizes=32x32 href=https://Xloading-919.github.io/img/logo.jpg><link rel=apple-touch-icon href=https://Xloading-919.github.io/logo.jpg><link rel=mask-icon href=https://Xloading-919.github.io/logo.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><style>body{font-family:lxgw wenkai,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head><body></body></html><meta property="og:url" content="https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Xloading's Blog"><meta property="og:title" content="多线程基础"><meta property="og:description" content="## 为什么要多线程 多线程可以：
充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-03T15:53:17+08:00"><meta property="article:modified_time" content="2025-10-03T15:53:17+08:00"><meta property="article:tag" content="并发基础"><meta name=twitter:card content="summary"><meta name=twitter:title content="多线程基础"><meta name=twitter:description content="## 为什么要多线程

多线程可以：

充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。
提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。
提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。

并行与并发

并行，是多核CPU上的多任务处理，是同一时间同时执行
并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现

互斥与同步

互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区
同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行
通过锁或者信号量机制实现。

信号量：

p操作：进入临界区前，将资源数量减1，可能阻塞
v操作：离开临界区后，将资源数量加1，不会阻塞





进程、线程、协程
这是三种并发执行单元："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://Xloading-919.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://Xloading-919.github.io/zh/posts/tech/"},{"@type":"ListItem","position":3,"name":"多线程基础","item":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"多线程基础","name":"多线程基础","description":"## 为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n","keywords":["并发基础"],"articleBody":"## 为什么要多线程 多线程可以：\n充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。 提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。 提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。 并行与并发 并行，是多核CPU上的多任务处理，是同一时间同时执行 并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现 互斥与同步 互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区 同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行 通过锁或者信号量机制实现。 信号量： p操作：进入临界区前，将资源数量减1，可能阻塞 v操作：离开临界区后，将资源数量加1，不会阻塞 进程、线程、协程 这是三种并发执行单元：\n进程：操作系统资源分配的单位。一个程序就是一个进程 线程：CPU调度的单位，运行在进程内部，共享进程的资源 协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。 内核态和用户态 根据进程访问资源的特点，把进程在系统上的运行分为两个级别：\n用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源 内核态：内核态的进程可以访问所有硬件资源 两种状态的切换有三种方式：\n系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。 中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。 异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。 线程状态 Java的线程在生命周期中有6种状态：\nnew：初始状态，线程刚创建还没有start runnable：运行状态，调用start blocked：阻塞状态，等待锁释放 waiting：等待状态，等待通知或中断唤醒，然后等待锁 time_waiting：超时等待状态，指定时间后返回，如果是obj.wait(timeout)，还需要等待锁，如果是Thread.sleep(timeout) 或 join(timeout)，不需要等待锁。 terminated：终止状态，线程运行完毕 线程上下文切换 线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。\n线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。\n线程安全是什么 线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。\n可以从三个要素来保证线程安全：\n原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。 可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。 有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。 死锁 死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。\n死锁需要四个条件：\n互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。 请求与保持条件：线程对于已经获取的资源不会放弃。 不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。 循环等待条件：多个线程依次循环等待资源。 预防死锁方法：\n破坏请求与保持条件：一次性申请所有资源。 破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。 破坏循环等待条件：按顺序申请资源，反序释放。 ","wordCount":"1657","inLanguage":"zh","datePublished":"2025-10-03T15:53:17+08:00","dateModified":"2025-10-03T15:53:17+08:00","author":[{"@type":"Person","name":"axing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Xloading-919.github.io/zh/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"Xloading's Blog","logo":{"@type":"ImageObject","url":"https://Xloading-919.github.io/img/logo.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Xloading-919.github.io/zh/ accesskey=h title="Xloading's Blog (Alt + H)">Xloading's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Xloading-919.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://Xloading-919.github.io/zh/posts title=文章><span>文章</span></a></li><li><a href=https://Xloading-919.github.io/zh/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://Xloading-919.github.io/zh/tags title=标签><span>标签</span></a></li><li><a href=https://Xloading-919.github.io/zh/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://Xloading-919.github.io/zh/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Xloading-919.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://Xloading-919.github.io/zh/posts/>所有文章</a>&nbsp;»&nbsp;<a href=https://Xloading-919.github.io/zh/posts/tech/>技术</a></div><h1 class="post-title entry-hint-parent">多线程基础</h1><div class=post-meta><span title='2025-10-03 15:53:17 +0800 +0800'>2025-10-03</span>&nbsp;·&nbsp;<span>4 分钟</span>&nbsp;·&nbsp;<span>axing</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%b9%b6%e8%a1%8c%e4%b8%8e%e5%b9%b6%e5%8f%91 aria-label=并行与并发>并行与并发</a></li><li><a href=#%e4%ba%92%e6%96%a5%e4%b8%8e%e5%90%8c%e6%ad%a5 aria-label=互斥与同步>互斥与同步</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b aria-label=进程、线程、协程>进程、线程、协程</a></li><li><a href=#%e5%86%85%e6%a0%b8%e6%80%81%e5%92%8c%e7%94%a8%e6%88%b7%e6%80%81 aria-label=内核态和用户态>内核态和用户态</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81 aria-label=线程状态>线程状态</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2 aria-label=线程上下文切换>线程上下文切换</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label=线程安全是什么>线程安全是什么</a></li><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a></li></ul></div></details></div><div class=post-content><pre><code>## 为什么要多线程
</code></pre><p>多线程可以：</p><ol><li>充分利用多核CPU的处理能力，可以让程序并行执行，提高吞吐量。</li><li>提升资源的利用率，一个线程在等待IO的时候，CPU可以调度其他线程继续工作。</li><li>提升程序的相应速度，可以把耗时的IO操作放到后台线程处理，主线程继续响应用户。</li></ol><h2 id=并行与并发>并行与并发<a hidden class=anchor aria-hidden=true href=#并行与并发>#</a></h2><ol><li>并行，是多核CPU上的多任务处理，是同一时间同时执行</li><li>并发，是单核CPU上的多任务处理，是同一个时间段内交替执行，其实是通过时间片轮转实现</li></ol><h2 id=互斥与同步>互斥与同步<a hidden class=anchor aria-hidden=true href=#互斥与同步>#</a></h2><ol><li>互斥是线程间要抢占资源，就是说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</li><li>同步是线程之间需要进行合作，并发的线程在一些任务上需要相互等待与互通消息，按照一定顺序执行</li><li>通过锁或者信号量机制实现。<ol><li>信号量：<ol><li>p操作：进入临界区前，将资源数量减1，可能阻塞</li><li>v操作：离开临界区后，将资源数量加1，不会阻塞</li></ol></li></ol></li></ol><h2 id=进程线程协程>进程、线程、协程<a hidden class=anchor aria-hidden=true href=#进程线程协程>#</a></h2><p>这是三种并发执行单元：</p><ol><li>进程：操作系统<strong>资源分配</strong>的单位。一个程序就是一个进程</li><li>线程：CPU调度的单位，运行在进程内部，共享进程的资源</li><li>协程：用户态的轻量级线程，由程序控制切换，本质是函数级别的上下文切换。协程的切换操作系统无法感知，节省了从用户态到内核态的切换开销。</li></ol><h2 id=内核态和用户态>内核态和用户态<a hidden class=anchor aria-hidden=true href=#内核态和用户态>#</a></h2><p>根据进程访问资源的特点，把进程在系统上的运行分为两个级别：</p><ol><li>用户态：用户态的进程只能访问自己分配的虚拟内存数据和受限的系统资源</li><li>内核态：内核态的进程可以访问所有硬件资源</li></ol><p>两种状态的切换有三种方式：</p><ol><li>系统调用：用户态进程主动切换。比如文件操作、网络IO、线程管理。</li><li>中断：外围设备完成操作后，会向CPU发送中断信号，CPU会暂停用户态程序执行，进入内核态处理。比如磁盘IO完成、时钟中断（系统定时器，用于线程抢占）、网络包到达。</li><li>异常：程序执行中出现异常（非法操作或特权指令）时，CPU 自动切换到内核态处理。比如非法内存访问、除零异常。</li></ol><h2 id=线程状态>线程状态<a hidden class=anchor aria-hidden=true href=#线程状态>#</a></h2><p>Java的线程在生命周期中有6种状态：</p><ol><li>new：初始状态，线程刚创建还没有start</li><li>runnable：运行状态，调用start</li><li>blocked：阻塞状态，等待锁释放</li><li>waiting：等待状态，等待通知或中断唤醒，然后等待锁</li><li>time_waiting：超时等待状态，指定时间后返回，如果是<code>obj.wait(timeout)</code>，还需要等待锁，如果是<code>Thread.sleep(timeout)</code> 或 <code>join(timeout)</code>，不需要等待锁。</li><li>terminated：终止状态，线程运行完毕</li></ol><h2 id=线程上下文切换>线程上下文切换<a hidden class=anchor aria-hidden=true href=#线程上下文切换>#</a></h2><p>线程上下文切换就是说每个线程执行时都有自己的运行条件和状态（上下文），比如程序计数器，栈信息等。当线程从占用CPU的状态退出，等待下一次运行的时候，就要保存当前线程的上下文，并加载下一个将要占用CPU的线程的上下文。</p><p>线程的切换实际是说的内核态线程的切换。上下文的内容包括：CPU寄存器，内核栈指针等；如果是不同进程的线程还需要切换虚拟内存这些信息。</p><h2 id=线程安全是什么>线程安全是什么<a hidden class=anchor aria-hidden=true href=#线程安全是什么>#</a></h2><p>线程安全其实可以理解为多个线程在操作共享数据的时候，对于数据的处理逻辑是正确的，保证数据的正确性和一致性。</p><p>可以从三个要素来保证线程安全：</p><ol><li>原子性：对于数据的操作，要么全部执行，要么不不执行，不会出现中间状态。这个通过加锁、原子操作实现。</li><li>可见性：一个线程修改了共享变量之后，其他线程要能立即看到变化。这个通过加锁和volatile关键字可以实现。</li><li>有序性：程序的执行顺序与代码编写顺序保持一致，不会被 CPU 或编译器重排序打乱。通过加锁和volatile关键字可以实现。</li></ol><h2 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>#</a></h2><p>死锁是指多个线程同时阻塞，在互相等待对方释放资源，导致程序不能正常终止。</p><p>死锁需要四个条件：</p><ol><li>互斥条件：等待的资源的访问是互斥的，任意时刻只能有一个线程占有。</li><li>请求与保持条件：线程对于已经获取的资源不会放弃。</li><li>不可剥夺条件：线程已经获得的资源不能被其他线程抢占，只能自己释放。</li><li>循环等待条件：多个线程依次循环等待资源。</li></ol><p>预防死锁方法：</p><ol><li>破坏请求与保持条件：一次性申请所有资源。</li><li>破坏不可剥夺条件：占用部分资源的线程如果进一步申请资源失败，可以主动释放它占有的资源。</li><li>破坏循环等待条件：按顺序申请资源，反序释放。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://Xloading-919.github.io/zh/tags/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/>并发基础</a></li></ul><nav class=paginav><a class=prev href=https://Xloading-919.github.io/zh/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/><span class=title>« 上一页</span><br><span>十大排序算法总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://Xloading-919.github.io/zh/>Xloading's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>